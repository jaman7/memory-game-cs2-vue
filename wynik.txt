.lintstagedrc
{
  '{,src/**/}*.{md,json,ts,tsx,js,jsx,vue,css,scss,html,yml,vue}': ['git add']
}


.prettierrc.json
{
  "$schema": "https://json.schemastore.org/prettierrc",
  "tabWidth": 2,
  "useTabs": false,
  "semi": true,
  "singleQuote": true,
  "printWidth": 160,
  "trailingComma": "es5",
  "bracketSpacing": true,
  "arrowParens": "always",
  "endOfLine": "lf",
  "useEditorConfig": true
}

env.d.ts
/// <reference types="vue/macros-global" />
/// <reference types="vite/client" />
/// <reference types="vitest" />

declare module '*.vue' {
  import { DefineComponent } from 'vue';
  const component: DefineComponent<{}, {}, any>;
  export default component;
}


eslint.config.ts
import pluginVitest from '@vitest/eslint-plugin';
import skipFormatting from '@vue/eslint-config-prettier/skip-formatting';
import { defineConfigWithVueTs, vueTsConfigs } from '@vue/eslint-config-typescript';
import jsxA11y from 'eslint-plugin-jsx-a11y';
import pluginVue from 'eslint-plugin-vue';
import { globalIgnores } from 'eslint/config';
import vueParser from 'vue-eslint-parser';

export default defineConfigWithVueTs(
  {
    name: 'app/files-to-lint',
    files: ['**/*.{ts,mts,tsx,vue}'],
    languageOptions: {
      parser: vueParser,
      parserOptions: {
        parser: '@typescript-eslint/parser',
        ecmaVersion: 2020,
        sourceType: 'module',
      },
    },
  },

  globalIgnores(['**/dist/**', '**/dist-ssr/**', '**/coverage/**']),

  pluginVue.configs['flat/recommended'],
  pluginVue.configs['flat/strongly-recommended'],
  vueTsConfigs.recommended,

  {
    ...pluginVitest.configs.recommended,
    files: ['**/__tests__/**/*', '**/*.spec.*', '**/*.test.*'],
    plugins: {
      'jsx-a11y': jsxA11y,
    },
    rules: {
      'vue/no-parsing-error': 'error',
      'jsx-a11y/aria-role': 'warn',
      'jsx-a11y/lang': 'warn',
      'jsx-a11y/no-autofocus': 'warn',
      'jsx-a11y/alt-text': 'warn',
      'no-console': 'warn',
      quotes: ['error', 'single'],
      semi: ['error', 'always'],
    },
  },

  skipFormatting
);


index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Memory CS2 – Memory game</title>
    <meta name="description" content="Play Memory CS2 and test your memory with Counter-Strike 2 weapons!" />
    <meta name="theme-color" content="#1f2937" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,500;0,700;0,900;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet" />
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>


package.json
{
  "name": "vue-memory-game-cs2",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "build-only": "vite build",
    "type-check": "vue-tsc --build",
    "lint": "eslint . --fix",
    "format": "prettier --write src/",
    "prepare": "husky install",
    "test:unit": "vitest run",
    "test:watch": "vitest",
    "test:ui": "vitest --ui",
    "coverage": "vitest run --coverage"
  },
  "lint-staged": {
    "*.{js,ts,vue}": "eslint --fix",
    "*.{js,ts,vue,css,scss,html,json,md}": "prettier --write"
  },
  "dependencies": {
    "@vueuse/core": "^13.2.0",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "howler": "^2.2.4",
    "oh-vue-icons": "^1.0.0-rc3",
    "pinia": "^3.0.3",
    "seedrandom": "^3.0.5",
    "vue": "^3.5.13",
    "vue-i18n": "^11.1.5"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.6.3",
    "@tsconfig/node22": "^22.0.1",
    "@types/eslint-plugin-jsx-a11y": "^6.10.0",
    "@types/howler": "^2.2.12",
    "@types/jsdom": "^21.1.7",
    "@types/node": "^22.14.0",
    "@types/seedrandom": "^3.0.8",
    "@typescript-eslint/parser": "^8.34.1",
    "@vitejs/plugin-vue": "^5.2.3",
    "@vitejs/plugin-vue-jsx": "^4.1.2",
    "@vitest/coverage-v8": "^3.1.3",
    "@vitest/eslint-plugin": "^1.1.39",
    "@vitest/ui": "^3.1.3",
    "@vue/eslint-config-prettier": "^10.2.0",
    "@vue/eslint-config-typescript": "^14.5.0",
    "@vue/test-utils": "^2.4.6",
    "@vue/tsconfig": "^0.7.0",
    "eslint": "^9.22.0",
    "eslint-import-resolver-typescript": "^4.3.4",
    "eslint-plugin-jsx-a11y": "^6.10.2",
    "eslint-plugin-vue": "~10.0.0",
    "fast-glob": "^3.3.3",
    "husky": "^9.1.7",
    "jiti": "^2.4.2",
    "jsdom": "^26.0.0",
    "lint-staged": "^16.0.0",
    "npm-run-all2": "^7.0.2",
    "postcss": "^8.5.3",
    "prettier": "3.5.3",
    "rollup-plugin-visualizer": "^6.0.3",
    "sass": "^1.89.0",
    "stylelint": "^16.19.1",
    "stylelint-config-recommended": "^16.0.0",
    "stylelint-config-standard-scss": "^15.0.0",
    "stylelint-order": "^7.0.0",
    "ts-node": "^10.9.2",
    "typescript": "~5.8.0",
    "unplugin-auto-import": "^19.2.0",
    "unplugin-vue-components": "^28.5.0",
    "vite": "^6.2.4",
    "vite-plugin-inspect": "^11.2.0",
    "vite-plugin-vue-devtools": "^7.7.2",
    "vitest": "^3.1.3",
    "vue-eslint-parser": "^10.1.3",
    "vue-tsc": "^2.2.8"
  },
  "recommendations": [
    "esbenp.prettier-vscode",
    "dbaeumer.vscode-eslint",
    "stylelint.vscode-stylelint",
    "yoavbls.pretty-ts-errors"
  ],
  "browserslist": [
    "last 5 Chrome versions",
    "last 15 Firefox versions",
    "last 4 Edge major versions",
    "last 4 Safari major versions",
    "last 2 iOS major versions",
    "Firefox ESR",
    "not ios_saf 15.2-15.3",
    "not safari 15.2-15.3"
  ]
}


tsconfig.app.json
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "include": [
    "env.d.ts",
    "src/**/*.ts",
    "src/**/*.d.ts",
    "src/**/*.vue",
    "src/**/*.test.ts"
  ],
  "exclude": [
    "src/**/__tests__/*"
  ],
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "types": [
      "node",
    ]
  }
}


tsconfig.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "src/*"
      ],
      "@scss/*": [
        "src/assests/scss/*"
      ]
    }
  },
  "files": [],
  "references": [
    {
      "path": "./tsconfig.node.json"
    },
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.vitest.json"
    }
  ]
}

tsconfig.node.json
{
  "extends": "@tsconfig/node22/tsconfig.json",
  "include": [
    "vite.config.*",
    "vitest.config.*",
    "cypress.config.*",
    "nightwatch.conf.*",
    "playwright.config.*",
    "eslint.config.*"
  ],
  "compilerOptions": {
    "noEmit": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "types": [
      "node"
    ]
  }
}


tsconfig.vitest.json
{
  "extends": "./tsconfig.app.json",
  "include": [
    "src/**/__tests__/*",
    "env.d.ts"
  ],
  "exclude": [],
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.vitest.tsbuildinfo",
    "lib": [],
    "types": [
      "vitest",
      "node",
      "jsdom"
    ]
  }
}

vite.config.ts
import vue from '@vitejs/plugin-vue';
import vueJsx from '@vitejs/plugin-vue-jsx';
import path from 'path';
import { visualizer } from 'rollup-plugin-visualizer';
import AutoImport from 'unplugin-auto-import/vite';
import { VueUseComponentsResolver } from 'unplugin-vue-components/resolvers'; // opcjonalne
import Components from 'unplugin-vue-components/vite';
import { defineConfig } from 'vite';
import vueDevTools from 'vite-plugin-vue-devtools';

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    vueJsx(),
    vueDevTools(),
    AutoImport({
      imports: ['vue', 'vue-router', '@vueuse/core'],
      dts: 'src/auto-imports.d.ts',
      vueTemplate: true,
    }),
    Components({
      dirs: ['src/components', 'src/shared/components'],
      extensions: ['vue'],
      deep: true,
      dts: 'src/components.d.ts',
      resolvers: [VueUseComponentsResolver()],
      exclude: [],
    }),
    visualizer({
      filename: 'dist/report.html',
      open: true,
      gzipSize: true,
      brotliSize: true,
    }),
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@utils': path.resolve(__dirname, './src/shared/utils'),
      '@scss': path.resolve(__dirname, './src/assests/scss'),
    },
  },
  css: {
    preprocessorOptions: {
      scss: {
        quietDeps: true,
        api: 'modern-compiler',
        silenceDeprecations: ['mixed-decls', 'color-functions', 'global-builtin', 'import'],
        additionalData: `@use "@scss/mixins.scss"; @use "@scss/variables.scss";`,
      },
    },
    devSourcemap: true,
  },
  optimizeDeps: {
    include: ['pinia', 'howler', '@vueuse/core'],
  },
  build: {
    target: 'esnext',
    chunkSizeWarningLimit: 700,
    minify: 'esbuild',
    rollupOptions: {
      output: {
        manualChunks: {
          vue: ['vue', 'pinia', 'vue-i18n', '@vueuse/core'],
          vendor: ['howler', 'clsx', 'oh-vue-icons'],
          canvas: [
            '@/hooks/useCanvasRenderer',
            '@/hooks/useMouseCanvasPosition',
            '@/hooks/useMouseTileHover',
            '@/hooks/useThrottledDraw',
            '@/shared/utils/canvasRenderer',
          ],
          game: ['@/hooks/useTileInteractions', '@/hooks/useGamePersistence', '@/stores/useGameStore', '@/stores/useGameHistoryStore'],
          ui: [
            '@/components/Sidebar/Sidebar.vue',
            '@/components/Sidebar/VolumeControl/VolumeControl.vue',
            '@/components/DevPanel/DevPanel.vue',
            '@/components/GameOverModal.vue',
            '@/components/StartModal.vue',
          ],
        },
      },
    },
  },
  define: {
    'process.env': {},
  },
  worker: {
    format: 'es',
  },
});


vitest.config.ts
import { dirname } from 'path';
import { fileURLToPath } from 'url';
import { configDefaults, defineConfig, mergeConfig } from 'vitest/config';
import viteConfig from './vite.config';

const __dirname = dirname(fileURLToPath(import.meta.url));

export default mergeConfig(
  viteConfig,
  defineConfig({
    test: {
      environment: 'jsdom',
      exclude: [...configDefaults.exclude, 'e2e/**', 'dist/**'],
      root: __dirname,
      setupFiles: ['./vitest.setup.ts'],
      globals: true,
      coverage: {
        provider: 'v8',
        reporter: ['text', 'json', 'html'],
      },
    },
  })
);


vitest.setup.ts
import * as matchers from '@testing-library/jest-dom/matchers';
import { config } from '@vue/test-utils';
import { beforeAll, expect } from 'vitest';
import { createI18n } from 'vue-i18n';

expect.extend(matchers);

const i18n = createI18n({
  legacy: false,
  locale: 'en',
  messages: {
    en: {},
  },
});

beforeAll(() => {
  config.global.plugins = [i18n];
});

global.IntersectionObserver = class IntersectionObserver {
  root: Element | null = null;
  rootMargin: string = '';
  thresholds: ReadonlyArray<number> = [];

  constructor(callback: IntersectionObserverCallback, options?: IntersectionObserverInit) {}

  observe() {}
  unobserve() {}
  disconnect() {}
  takeRecords(): IntersectionObserverEntry[] {
    return [];
  }
};


src\App.vue
<template>
  <div class="layout">
    <Spinner v-if="isLoading" key="loading" size="large" ariaLabel="Loadnig.." />
    <StartModal v-else-if="!gameStore.gameStarted" key="start" @start="handleStart" />
    <GameCanvas v-else key="canvas" :seed="gameStore.seed" :difficulty="gameStore.difficulty" @newGame="handleStartModal" />
    <transition name="fade-panel">
      <DevPanel v-if="gameStore.devPanelVisible" />
    </transition>
  </div>
</template>

<script setup lang="ts">
import { useGameStart } from './hooks/useGameStart';
import { useGameStateStorage } from './hooks/useGameStateStorage';
import { useGameHistoryStore } from './stores/useGameHistoryStore';
import { useGameStore } from './stores/useGameStore';

const gameStore = useGameStore();
const { isLoading, startGame } = useGameStart();
const { load } = useGameStateStorage();

defineEmits<{
  (e: 'newGame'): void;
}>();

async function handleStart(payload: { seed: string; difficulty: number }) {
  const result = await startGame(payload);
  gameStore.startGame(result);
}

async function handleStartModal(e: string) {
  gameStore.setGameStarted(false);
  gameStore.setGameOver(false);
}

onMounted(() => {
  const saved = load();
  useGameHistoryStore().loadFromStorage();
  if (saved) {
    const anyMatched = saved.tiles.some((t) => t.matched);
    if (anyMatched) {
      gameStore.restoreGame(saved);
    } else {
      gameStore.setGameStarted(false);
    }
  }
});
</script>


src\components.d.ts
/* eslint-disable */
// @ts-nocheck
// Generated by unplugin-vue-components
// Read more: https://github.com/vuejs/core/pull/3399
// biome-ignore lint: disable
export {}

/* prettier-ignore */
declare module 'vue' {
  export interface GlobalComponents {
    Button: typeof import('./shared/components/Button/Button.vue')['default']
    CollapsiblePanel: typeof import('./shared/components/CollapsiblePanel/CollapsiblePanel.vue')['default']
    DevPanel: typeof import('./components/DevPanel/DevPanel.vue')['default']
    GameCanvas: typeof import('./components/GameCanvas/GameCanvas.vue')['default']
    GameHistory: typeof import('./components/Sidebar/GameHistory/GameHistory.vue')['default']
    GameOverModal: typeof import('./components/GameOverModal.vue')['default']
    InputField: typeof import('./shared/components/InputField/InputField.vue')['default']
    LazyImage: typeof import('./shared/components/LazyImage/LazyImage.vue')['default']
    Matches: typeof import('./components/Sidebar/Matches/Matches.vue')['default']
    SelectField: typeof import('./shared/components/SelectField/SelectField.vue')['default']
    Sidebar: typeof import('./components/Sidebar/Sidebar.vue')['default']
    Spinner: typeof import('./shared/components/Spinner/Spinner.vue')['default']
    StartModal: typeof import('./components/StartModal.vue')['default']
    TilePreview: typeof import('./components/Sidebar/TilePreview/TilePreview.vue')['default']
    VolumeControl: typeof import('./components/Sidebar/VolumeControl/VolumeControl.vue')['default']
  }
}


src\i18n.ts
import { createI18n } from 'vue-i18n';

export const availableLocales = ['en', 'pl'];

export const i18n = createI18n({
  legacy: false,
  locale: 'pl',
  fallbackLocale: 'en',
  messages: {},
});


src\icons.ts
import { OhVueIcon, addIcons } from 'oh-vue-icons';
import { FaBars, FaCheck, FaChevronDown, FaHistory, FaSave, FaTimes, FaTools, FaUndo } from 'oh-vue-icons/icons/fa';

addIcons(FaTools, FaHistory, FaSave, FaUndo, FaTimes, FaChevronDown, FaBars, FaCheck);

export { OhVueIcon };


src\main.ts
import { createPinia } from 'pinia';
import { createApp } from 'vue';
import App from './App.vue';
import './assests/scss/main.scss';
import { availableLocales, i18n } from './i18n';
import { OhVueIcon } from './icons';

const app = createApp(App);
const pinia = createPinia();

app.use(i18n);
app.use(pinia);
app.component('VIcon', OhVueIcon);

async function loadLocale(locale: string) {
  if (!availableLocales.includes(locale)) return;

  const messages = await fetch(`/i18n/${locale}.json`).then((res) => res.json());
  i18n.global.setLocaleMessage(locale, messages);
  i18n.global.locale.value = locale;
}

let initialLocale = localStorage.getItem('user-locale');

if (!initialLocale) {
  const browserLang = navigator.language.split('-')[0];
  if (availableLocales.includes(browserLang)) {
    initialLocale = browserLang;
  } else {
    initialLocale = 'en';
  }
  localStorage.setItem('user-locale', initialLocale);
}

loadLocale(initialLocale).then(() => {
  app.mount('#app');
});

export { loadLocale };


src\components\GameOverModal.vue
<template>
  <div class="modal">
    <div class="modal-content">
      <h2 class="modal-title mb-2">{{ $t('modalEnd.title') }}</h2>
      <p class="modal-message">{{ $t('modalEnd.message', { time, moves }) }}</p>

      <div class="modal-actions">
        <Button name="modalEnd.buttonReplay" :handleClick="() => $emit('restart')" />
        <Button name="modalEnd.buttonNew" :handleClick="() => $emit('newgame')" />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
const props = defineProps<{
  time: string;
  moves: number;
}>();

defineEmits<{
  (e: 'restart'): void;
  (e: 'newgame'): void;
}>();
</script>


src\components\StartModal.vue
<!-- StartModal.vue -->
<!-- lazy -->
<template>
  <div class="modal" role="dialog" aria-modal="true">
    <div class="modal-content">
      <h2 class="modal-title mb-2">{{ $t('modalStart.title') }}</h2>

      <p class="modal-info">
        {{ $t('modalStart.noActiveGameInfo') }}
      </p>

      <InputField
        id="seed"
        v-model="localSeed"
        :label="$t('modalStart.seedLabel')"
        :placeholder="'np. awp-king'"
        :description="$t('modalStart.seed')"
        describedby="seed-desc"
      />

      <SelectField
        id="difficulty"
        v-model="localDifficulty"
        :label="$t('modalStart.difficultyLabel')"
        :description="$t('modalStart.difficulty')"
        describedby="difficulty-desc"
        :options="difficulties"
      />
      <p id="difficulty-desc" class="sr-only mb-2">{{ $t('modalStart.difficulty') }}</p>

      <div class="modal-actions">
        <Button name="modalStart.button" :handleClick="startGame" />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, ref } from 'vue';
import { useI18n } from 'vue-i18n';

defineOptions({
  inheritAttrs: false,
});
defineProps<{}>();

const { t } = useI18n();
const emit = defineEmits<{
  (e: 'start', payload: { seed: string; difficulty: number }): void;
}>();

const localSeed = ref('');
const localDifficulty = ref(1);

const difficulties = computed(() => [
  { id: 1, displayName: t('difficultyDict.easy') },
  { id: 2, displayName: t('difficultyDict.medium') },
  { id: 3, displayName: t('difficultyDict.hard') },
]);

function startGame() {
  emit('start', {
    seed: localSeed.value.trim(),
    difficulty: localDifficulty.value,
  });
}
</script>


src\components\DevPanel\DevPanel.vue
<script setup lang="ts">
import { useFormattedTime } from '@/hooks/useFormattedTime';
import { useGamePersistence } from '@/hooks/useGamePersistence';
import { useGameHistoryStore } from '@/stores/useGameHistoryStore';
import { useGameStore } from '@/stores/useGameStore';
import { computed } from 'vue';

const gameStore = useGameStore();
const historyStore = useGameHistoryStore();
const history = historyStore.history;
const formattedTime = useFormattedTime(computed(() => gameStore.elapsed));
const { saveState, clearState } = useGamePersistence(gameStore.seed, gameStore.difficulty);

function handleSave() {
  saveState(gameStore.gameState);
}

function handleReset() {
  clearState();
  gameStore.setGameStarted(false);
}

const statePreview = computed(() => ({
  seed: gameStore.seed,
  difficulty: gameStore.difficulty,
  moves: gameStore.moves,
  elapsed: formattedTime.value as string,
  tilesMatched: gameStore.tiles.filter((t) => t.matched).length,
  gameStarted: gameStore.gameStarted,
  gameOver: gameStore.gameOver,
  sidebarVisible: gameStore.sidebarVisible,
  devPanelVisible: gameStore.devPanelVisible,
  tiles: gameStore.tiles,
}));
</script>

<!-- DevPanel.vue -->
<!-- lazy -->
<template>
  <div class="dev-panel">
    <div class="dev-panel__header">
      <h3 class="dev-panel__title"><VIcon name="fa-tools" /> {{ $t('devToolPanel.title') }}</h3>
      <Button :handleClick="() => gameStore.toggleDevPanel()" variant="round" aria-label="Close Dev Panel"><VIcon name="fa-times" /></Button>
    </div>

    <pre class="dev-panel__preview">{{ JSON.stringify(statePreview, null, 2) }}</pre>

    <CollapsiblePanel :title="$t('devToolPanel.history')">
      <pre class="dev-panel__preview">{{ JSON.stringify(history, null, 2) }}</pre>
    </CollapsiblePanel>

    <div class="dev-panel__buttons">
      <Button :handleClick="handleSave" className="gap-8"><VIcon name="fa-save" /> {{ $t('devToolPanel.btnSave') }}</Button>
      <Button :handleClick="handleReset" className="gap-8"><VIcon name="fa-undo" /> {{ $t('devToolPanel.btnReset') }}</Button>
    </div>

    <h4 class="dev-panel__subtitle"><VIcon name="fa-history" /> {{ $t('devToolPanel.history') }}</h4>
  </div>
</template>

<style scoped src="./DevPanel.scss" />


src\components\GameCanvas\GameCanvas.const.ts
import type { Rarity, Tile } from './GameCanvas.types';

export const RarityColors: Record<Tile['rarity'], string> = {
  consumer: '#999999',
  industrial: '#5a9bd4',
  milspec: '#4b6cb7',
  restricted: '#cf6ccf',
  classified: '#f55',
  covert: '#f2b01e',
};

export const RarityBorders: Record<Rarity, string> = {
  consumer: '#b0b0b0',
  industrial: '#5e98d9',
  milspec: '#4b69ff',
  restricted: '#8847ff',
  classified: '#d32ce6',
  covert: '#eb4b4b',
};

export const colors: Record<string, string> = {
  black: '#000',
  tonedBlack: '#222',
  gray: '#444',
  darkBlue: '#0860d8',
  lightGray: 'oklch(97.7% 0.013 236.62)',
  shadowColor: 'rgba(21, 93, 252, 0.8)',
};

export const fontRoboto = '12px Roboto';
export const LocalStorageName = 'memory-game-history';

export const rarities: Rarity[] = ['consumer', 'industrial', 'milspec', 'restricted', 'classified', 'covert'];

export const weapons = [
  'ak47',
  'aug',
  'awp',
  'cz75a',
  'deagle',
  'famas',
  'five-seven',
  'g3sg1',
  'galil-ar',
  'glock-18',
  'm249',
  'm4a1',
  'm4a4',
  'mac-10',
  'mag-7',
  'mp5-sd',
  'mp7',
  'mp9',
  'negev',
  'nova',
  'p2000',
  'p250',
  'p90',
  'pp-bizon',
  'revolver',
  'sawed-off',
  'scar-20',
  'sg-556',
  'ssg-08',
  'taser',
  'tec-9',
  'ump-45',
  'usp-s',
  'xm1014',
];


src\components\GameCanvas\GameCanvas.types.ts
export type Rarity = 'consumer' | 'industrial' | 'milspec' | 'restricted' | 'classified' | 'covert';
export type MatchResult = 'match' | 'mismatch';

export interface MatchRecord {
  a: Tile;
  b: Tile;
  result: MatchResult;
  timestamp?: number;
}

export interface GameHistoryEntry {
  dateStart: string | null;
  dateEnd: string | null;
  time: number;
  moves: number;
  seed: string;
  difficulty: number;
  matchCount: number;
  mismatchCount: number;
  matchedPairs: MatchRecord[];
}

export interface Tile {
  id: number;
  name: string;
  rarity: Rarity;
  pairId: number;
  flipped: boolean;
  matched: boolean;
  x: number;
  y: number;
  imagePath?: string;
  color?: string;
  value?: number;
  haloAngle?: number;
}

export interface Skin {
  id: number;
  name: string;
  imagePath: string;
  rarity: Rarity;
}

export interface GameState {
  dateStart: string | null;
  tiles: Tile[];
  elapsedSeconds: number;
  moves: number;
  seed: string;
  difficulty: number;
  matchCount: number;
  mismatchCount: number;
  matchedPairs: MatchRecord[];
}

export type ParallaxState = {
  mouseX: number;
  mouseY: number;
};


src\components\GameCanvas\GameCanvas.vue
<template>
  <div class="game-canvas">
    <div class="game-content" :class="{ 'with-sidebar': gameStore.sidebarVisible }">
      <div class="game-info">{{ formattedTime }} | {{ $t('game.moves', { n: gameStore.moves }) }}</div>

      <canvas ref="canvasRef" class="game-canvas-element" role="img" :aria-label="$t('game.canvasLabel')" :style="{ height: 'auto' }">
        {{ $t('errors.canvasFallBack') }}
      </canvas>

      <GameOverModal
        v-if="gameStore?.gameOver ?? false"
        :time="formattedTime ?? ''"
        :moves="gameStore.moves ?? 0"
        @restart="restartGame"
        @newgame="goToStart"
      />
    </div>

    <Sidebar @restart="restartGame" @newGame="goToStart" />
  </div>
</template>

<script setup lang="ts">
import { useBeforeUnloadBackup } from '@/hooks/useBeforeUnloadBackup';
import { useCanvasLayout } from '@/hooks/useCanvasLayout';
import { useCanvasRenderer } from '@/hooks/useCanvasRenderer';
import { useDebouncedRedraw } from '@/hooks/useDebouncedRedraw';
import { useFormattedTime } from '@/hooks/useFormattedTime';
import { useGamePersistence } from '@/hooks/useGamePersistence';
import { useMouseCanvasPosition } from '@/hooks/useMouseCanvasPosition';
import { useMouseTileHover } from '@/hooks/useMouseTileHover';
import { useResizeObserver } from '@/hooks/useResizeObserver';
import { useTileInteractions } from '@/hooks/useTileInteractions';
import { useTimer } from '@/hooks/useTimer';
import { sounds } from '@/shared/sounds/sounds';
import { throttle } from '@/shared/utils/throttle';
import { useGameHistoryStore } from '@/stores/useGameHistoryStore';
import { useGameStore } from '@/stores/useGameStore';
import { nextTick, onMounted, onUnmounted, ref } from 'vue';

const props = defineProps<{
  seed: string;
  difficulty: number;
}>();

const emit = defineEmits(['restart', 'newGame']);

const gameStore = useGameStore();
const historyStore = useGameHistoryStore();
const canvasRef = ref<HTMLCanvasElement | null>(null);
const parentElement = ref<HTMLElement | null>(null);
const currentTileSize = ref(100);
const fadeStartTime = ref<number | null>(null);
const tiles = computed(() => gameStore.tiles);

const { saveState, loadState, clearState } = useGamePersistence(gameStore.seed, gameStore.difficulty);

const throttledBackup = throttle(() => {
  saveState(gameStore.gameState);
}, 30000);

const { start, stop, reset } = useTimer(throttledBackup);
const elapsed = computed(() => gameStore.elapsed);
const formattedTime = useFormattedTime(elapsed);

function recordVictoryStats() {
  historyStore.addEntry({
    dateStart: gameStore.dateStart ?? new Date().toISOString(),
    time: gameStore.elapsed,
    moves: gameStore.moves,
    dateEnd: new Date().toISOString(),
    seed: gameStore.seed,
    difficulty: gameStore.difficulty,
    matchCount: gameStore.matchCount,
    mismatchCount: gameStore.mismatchCount,
    matchedPairs: gameStore.matchedPairs,
  });
}

function goToStart() {
  clearState();
  gameStore.setGameStarted(false);
  emit('newGame');
}

const { getMousePosition } = useMouseCanvasPosition(canvasRef);
const { hoveredTileId, mouseX, mouseY, handleMouseMove } = useMouseTileHover(canvasRef, tiles, currentTileSize, getMousePosition);
const { handleClick, resetInteractions, isGameOver } = useTileInteractions(
  canvasRef,
  tiles,
  mouseX,
  mouseY,
  hoveredTileId,
  {
    onGameOver: () => {
      recordVictoryStats();
      stop();
      gameStore.setGameOver(true);
      saveState(gameStore.gameState);
    },
    // onMatch: (a, b) => {
    //   console.log('Matched:', a.name);
    // },
    // onMismatch: (a, b) => {
    //   console.log('Mismatch:', a.name, b.name, a, b);
    // },
  },
  currentTileSize
);

const { applyTileLayout } = useCanvasLayout(canvasRef, tiles, currentTileSize);

const { startAnimationLoop, layoutAndRedraw } = useCanvasRenderer(
  canvasRef,
  tiles,
  mouseX,
  mouseY,
  hoveredTileId,
  currentTileSize,
  applyTileLayout,
  fadeStartTime
);

const { debouncedRedraw } = useDebouncedRedraw(layoutAndRedraw, 100);

function restartGame() {
  fadeStartTime.value = Date.now();
  gameStore.restartGame();
  gameStore.setGameOver(false);
  gameStore.setGameStarted(true);
  resetInteractions();
  debouncedRedraw();
  clearState();
  reset();
  start();
}

useResizeObserver(parentElement, () => debouncedRedraw());

onMounted(async () => {
  if (!canvasRef.value) return;
  useBeforeUnloadBackup();
  const saved = loadState();
  Object.values(sounds).forEach((s) => s.load());

  if (saved) {
    gameStore.restoreGame(saved);
  }

  resetInteractions();
  await nextTick();
  fadeStartTime.value = Date.now();
  layoutAndRedraw();

  canvasRef.value?.addEventListener('click', handleClick);
  window.addEventListener('mousemove', handleMouseMove);
  canvasRef.value?.addEventListener('touchstart', handleMouseMove, { passive: true });
  canvasRef.value?.addEventListener('touchmove', handleMouseMove, { passive: true });
  canvasRef.value?.addEventListener('touchend', handleClick);

  startAnimationLoop();

  parentElement.value = canvasRef.value?.parentElement ?? null;

  start();
});

onUnmounted(() => {
  stop();
  window.removeEventListener('mousemove', handleMouseMove);
  canvasRef.value?.removeEventListener('click', handleClick);

  canvasRef.value?.removeEventListener('touchstart', handleMouseMove);
  canvasRef.value?.removeEventListener('touchmove', handleMouseMove);
  canvasRef.value?.removeEventListener('touchend', handleClick);
});
</script>

<style scoped src="./GameCanvas.scss" />


src\components\Sidebar\Sidebar.vue
<template>
  <div :class="['sidebar', { open: gameStore.sidebarVisible }]">
    <Button className="sidebar-close" variant="round" :handleClick="() => gameStore.toggleSidebar(!gameStore.sidebarVisible)" aria-label="Zamknij panel">
      <VIcon name="fa-chevron-down" :class="{ rotated: gameStore.sidebarVisible }" class="arrow-icon" />
    </Button>

    <div class="sidebar-container">
      <div class="locale-switcher">
        <Button
          v-for="lang in locales"
          :key="lang.code"
          :handleClick="() => setLocale(lang.code)"
          :aria-label="lang.label"
          :active="currentLocale === lang.code"
          variant="round"
        >
          <LazyImage :src="lang.flag" alt="" className="flag" />
        </Button>
      </div>

      <h2 class="sidebar-title">{{ $t('sidebar.title') }}</h2>

      <div class="sidebar-info">
        <p>
          <strong>{{ $t('sidebar.time') }}</strong> {{ formattedTime ?? '' }}
        </p>
        <p>
          <strong>{{ $t('sidebar.dateStart') }}</strong> {{ formattedDateTime ?? '' }}
        </p>
        <p>
          <strong>{{ $t('sidebar.moves') }}</strong> {{ gameStore.moves ?? 0 }}
        </p>
        <p>
          <strong>{{ $t('sidebar.matchCount') }}</strong> {{ gameStore.matchCount ?? 0 }}
        </p>
        <p>
          <strong>{{ $t('sidebar.mismatchCount') }}</strong> {{ gameStore.mismatchCount ?? 0 }}
        </p>
        <p>
          <strong>{{ $t('sidebar.seed') }}</strong> {{ gameStore.seed ?? '' }}
        </p>
        <p>
          <strong>{{ $t('sidebar.difficulty') }}</strong> {{ difficultyLabel ?? '' }}
        </p>
      </div>

      <div class="sidebar-buttons">
        <Button :handleClick="() => $emit('restart')" :name="'sidebar.buttonReplay'" />
        <Button :name="'sidebar.buttonNew'" :handleClick="() => $emit('newGame')" />
      </div>

      <VolumeControl />

      <div class="sidebar-stats">
        <h3>{{ $t('sidebar.statsTitle') }}</h3>
        <p>{{ $t('sidebar.gamesPlayed') }}: {{ stats.games }}</p>
        <p>{{ $t('sidebar.avgTime') }}: {{ stats.avgTime }}</p>
        <p>{{ $t('sidebar.avgMoves') }}: {{ stats.avgMoves }}</p>
        <p>{{ $t('sidebar.totalMatches') }}: {{ stats.totalMatches }}</p>
        <p>{{ $t('sidebar.totalMismatches') }}: {{ stats.totalMismatches }}</p>
      </div>

      <Matches />

      <CollapsiblePanel :title="$t('rarityLegend.title')">
        <div class="rarity-legend">
          <div v-for="rarity in rarities" :key="rarity" class="legend-item">
            <span class="legend-color" :style="{ backgroundColor: RarityColors[rarity] }" />
            <span>{{ $t('rarityLegend.' + rarity) }}</span>
          </div>
        </div>
      </CollapsiblePanel>

      <CollapsiblePanel :title="$t('history.title')">
        <GameHistory :history="history" />
      </CollapsiblePanel>

      <div class="d-block">
        <Button name="sidebar.buttonDevTools" :handleClick="gameStore.toggleDevPanel" variant="secondary" />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { rarities, RarityColors } from '@/components/GameCanvas/GameCanvas.const';
import { useFormattedTime } from '@/hooks/useFormattedTime';
import { localeOptions } from '@/i18n/locales';
import { loadLocale } from '@/main';
import { useGameHistoryStore } from '@/stores/useGameHistoryStore';
import { useGameStore } from '@/stores/useGameStore';
import { computed } from 'vue';
import { useI18n } from 'vue-i18n';
import './Sidebar.scss';

const { t, locale } = useI18n();
const gameStore = useGameStore();
const { history } = useGameHistoryStore();

const currentLocale = ref(locale.value);
const locales = localeOptions;
const elapsed = computed(() => gameStore.elapsed);
const formattedTime = useFormattedTime(elapsed);
const formattedDateTime = useDateFormat(gameStore.dateStart ?? '', 'YYYY-MM-DD HH:mm:ss');

const difficultyLabel = computed(() => {
  switch (gameStore.difficulty) {
    case 1:
      return t('difficultyDict.easy');
    case 2:
      return t('difficultyDict.medium');
    case 3:
      return t('difficultyDict.hard');
    default:
      return t('difficultyDict.unknown');
  }
});

const stats = computed(() => {
  const games = history.length;
  const avgTime = useFormattedTime(ref(games ? Math.round(history.reduce((a, e) => a + e.time, 0) / games) : 0)).value;
  const avgMoves = games ? Math.round(history.reduce((a, e) => a + e.moves, 0) / games) : 0;
  const totalMatches = history.reduce((a, e) => a + (e.matchCount ?? 0), 0);
  const totalMismatches = history.reduce((a, e) => a + (e.mismatchCount ?? 0), 0);
  return { games, avgTime, avgMoves, totalMatches, totalMismatches };
});

async function setLocale(code: string) {
  if (code === locale.value) return;
  await loadLocale(code);
  localStorage.setItem('user-locale', code);
  locale.value = code;
  currentLocale.value = code;
}

defineEmits(['restart', 'newGame']);
</script>


src\components\Sidebar\GameHistory\GameHistory.vue
<template>
  <div class="game-history">
    <ul v-if="history.length > 0" class="history-list">
      <li v-for="(entry, index) in history" :key="index" class="history-item">
        <div class="history-seed">
          <b>{{ entry.seed }}</b> ({{ entry.difficulty }})
        </div>
        <div class="history-details">
          {{ $t('history.timeMoves', { time: entry.time, moves: entry.moves }) }}
        </div>
        <div class="history-details">
          {{ $t('history.matchedCount', { matchCount: entry.matchCount, mismatchCount: entry.mismatchCount }) }}
        </div>
        <div class="history-date">
          {{ formatDate(entry?.dateStart ?? '') }}
        </div>

        <CollapsiblePanel :title="$t('history.matchedMismatch')" :size="'xs'">
          <div class="match-history-list">
            <div v-if="!entry.matchedPairs.length" class="match-history-list--empty-msg">{{ $t('devToolPanel.matchHistory.empty') }}</div>
            <div v-else class="match-history-list--list">
              <div v-for="(item, index) in entry.matchedPairs" :key="index" class="match-history-list--entry">
                <div class="type">
                  <span class="time">at: {{ item.timestamp ? useFormattedTime(ref(Number((item.timestamp / 1000).toFixed(1)))) : '' }}</span>
                  <template v-if="item.result === 'match'"
                    ><span class="match"><VIcon name="fa-check" /> {{ $t('devToolPanel.matchHistory.match') }}</span></template
                  >
                  <template v-else
                    ><span class="mismatch"><VIcon name="fa-times" /> {{ $t('devToolPanel.matchHistory.mismatch') }}</span></template
                  >
                </div>
                <div class="match-history-list--pair">
                  <TilePreview :tile="item.a" />
                  <span class="vs">vs</span>
                  <TilePreview :tile="item.b" />
                </div>
              </div>
            </div>
          </div>
        </CollapsiblePanel>
      </li>
    </ul>
    <p v-else class="history-empty">{{ $t('history.error') }}</p>
  </div>
</template>

<script setup lang="ts">
import type { GameHistoryEntry } from '@/components/GameCanvas/GameCanvas.types';
import { useFormattedTime } from '@/hooks/useFormattedTime';
import './GameHistory.scss';

defineProps<{
  history: GameHistoryEntry[];
}>();

function formatDate(iso: string) {
  return new Date(iso).toLocaleString('pl-PL');
}
</script>


src\components\Sidebar\Matches\Matches.vue
<template>
  <div v-if="lastMatch?.result" class="sidebar-last-match" :class="lastMatch?.result">
    <p class="label" :class="lastMatch?.result">
      <template v-if="lastMatch?.result === 'match'"><VIcon name="fa-check" /> {{ $t('sidebar.matches.match') }}</template>
      <template v-else><VIcon name="fa-times" /> {{ $t('sidebar.matches.mismatch') }}</template>
    </p>
    <div class="tiles">
      <div class="tile-preview">
        <LazyImage :src="lastMatch?.a?.imagePath" :alt="lastMatch?.a?.name" :className="lastMatch?.result" />
        <span class="name">{{ lastMatch?.a?.name }}</span>
      </div>
      <div class="tile-preview">
        <LazyImage :src="lastMatch?.b?.imagePath" :alt="lastMatch?.b?.name" :className="lastMatch?.result" />
        <span class="name">{{ lastMatch?.b?.name }}</span>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useGameStore } from '@/stores/useGameStore';
import './Matches.scss';

const gameStore = useGameStore();
const lastMatch = computed(() => gameStore.matchedPairs?.[gameStore?.matchedPairs?.length - 1] ?? null);
</script>


src\components\Sidebar\TilePreview\TilePreview.vue
<template>
  <div class="tile-preview">
    <LazyImage :src="tile.imagePath" :alt="tile.name" className="tile-preview--image" />
    <div class="tile-preview--info">
      <span class="tile-preview--name">{{ tile.name }}</span>
      <span class="tile-preview--rarity">{{ tile.rarity }}</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { Tile } from '@/components/GameCanvas/GameCanvas.types';
import './TilePreview.scss';
defineProps<{ tile: Tile }>();
</script>


src\components\Sidebar\VolumeControl\VolumeControl.vue
<template>
  <div
    class="volume-control"
    :style="{
      '--val': localVolume,
      '--min': 0,
      '--max': 100,
      '--pos': `calc((var(--val) - var(--min)) / (var(--max) - var(--min)) * 100%)`,
    }"
  >
    <div class="volume-header">
      <span class="volume-label">{{ $t('volumeControl.title') }}</span>
      <Button :handleClick="toggleMute" :aria-label="isMuted ? 'speaker off' : 'speaker on'" :className="clsx('speaker', { muted: isMuted })" variant="round">
        <LazyImage :src="`/images/speaker${isMuted ? '-muted' : ''}.svg`" :alt="`speaker${isMuted ? '-muted' : ''}`" />
      </Button>
    </div>

    <div class="volume-slider-wrapper">
      <input
        type="range"
        class="range-volume"
        min="0"
        max="100"
        step="1"
        v-model.number="localVolume"
        @input="onVolumeChange"
        aria-label="G³oœnoœæ"
        list="volume-ticks"
      />
      <div class="volume-indicator">{{ localVolume }}%</div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useSoundStore } from '@/stores/useSoundStore';
import { clsx } from 'clsx';
import { storeToRefs } from 'pinia';
import { ref, watch } from 'vue';

const soundStore = useSoundStore();
const { isMuted, volume } = storeToRefs(soundStore);
const { toggleMute, setVolume } = soundStore;

const localVolume = ref(Math.round(volume.value * 100));

watch(volume, (v) => {
  if (!isMuted.value) {
    localVolume.value = Math.round(v * 100);
  }
});

function onVolumeChange() {
  setVolume(localVolume.value / 100);
}
</script>

<style scoped src="./VolumeControl.scss" />


src\hooks\useBeforeUnloadBackup.ts
import { useGamePersistence } from '@/hooks/useGamePersistence';
import { useGameStore } from '@/stores/useGameStore';
import { onMounted, onUnmounted } from 'vue';

export function useBeforeUnloadBackup() {
  const gameStore = useGameStore();
  const { saveState } = useGamePersistence(gameStore.seed, gameStore.difficulty);

  function handleUnload() {
    saveState(gameStore.gameState);
  }

  onMounted(() => {
    window.addEventListener('beforeunload', handleUnload);
    window.addEventListener('pagehide', handleUnload);
  });

  onUnmounted(() => {
    window.removeEventListener('beforeunload', handleUnload);
    window.removeEventListener('pagehide', handleUnload);
  });
}


src\hooks\useCanvasLayout.ts
import type { Tile } from '@/components/GameCanvas/GameCanvas.types';
import type { Ref } from 'vue';

export function useCanvasLayout(canvasRef: Ref<HTMLCanvasElement | null>, tiles: Ref<Tile[]>, currentTileSize: Ref<number>) {
  function layoutCanvas(width: number, height: number) {
    const canvas = canvasRef.value;
    if (!canvas) return;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;

    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
  }

  function applyTileLayout() {
    const container = canvasRef.value?.parentElement;
    if (!container) return;

    const tileCount = tiles.value.length;
    const maxCols = 6;
    const spacing = 10;
    const padding = 20;

    const cols = Math.min(maxCols, Math.ceil(Math.sqrt(tileCount)));
    const rows = Math.ceil(tileCount / cols);

    const maxWidth = container.clientWidth;
    const maxHeight = window.innerHeight - 92 - 16 - 2;

    const tileSizeByWidth = Math.floor((maxWidth - padding * 2 - spacing * (cols - 1)) / cols);
    const tileSizeByHeight = Math.floor((maxHeight - padding * 2 - spacing * (rows - 1)) / rows);
    const tileSize = Math.min(tileSizeByWidth, tileSizeByHeight);

    currentTileSize.value = tileSize;

    const totalWidth = cols * tileSize + (cols - 1) * spacing + padding * 2;
    const totalHeight = rows * tileSize + (rows - 1) * spacing + padding * 2;

    tiles.value.forEach((tile, index) => {
      const row = Math.floor(index / cols);
      const col = index % cols;
      tile.x = col * (tileSize + spacing) + padding;
      tile.y = row * (tileSize + spacing) + padding;
    });

    layoutCanvas(totalWidth, totalHeight);
  }

  return {
    layoutCanvas,
    applyTileLayout,
  };
}


src\hooks\useCanvasRenderer.ts
import type { Tile } from '@/components/GameCanvas/GameCanvas.types';
import { drawBoard } from '@/shared/utils/canvasRenderer';
import type { Ref } from 'vue';

export function useCanvasRenderer(
  canvasRef: Ref<HTMLCanvasElement | null>,
  tiles: Ref<Tile[]>,
  mouseX: Ref<number>,
  mouseY: Ref<number>,
  hoveredTileId: Ref<number | null>,
  tileSize: Ref<number>,
  applyTileLayout: () => void,
  fadeStartTime?: Ref<number | null>
) {
  function redrawCanvas() {
    const canvas = canvasRef.value;
    const ctx = canvas?.getContext('2d');
    if (!canvas || !ctx) return;

    drawBoard(ctx, canvas, tiles.value, { x: mouseX.value, y: mouseY.value }, hoveredTileId.value, tileSize.value, fadeStartTime);
  }

  function startAnimationLoop() {
    function loop() {
      const canvas = canvasRef.value;
      const ctx = canvas?.getContext('2d');
      if (canvas && ctx) {
        tiles.value.forEach((tile) => {
          if (tile.matched && tile.haloAngle !== undefined) {
            tile.haloAngle = (tile.haloAngle + 0.03) % (Math.PI * 2);
          }
        });
        drawBoard(ctx, canvas, tiles.value, { x: mouseX.value, y: mouseY.value }, hoveredTileId.value, tileSize.value, fadeStartTime);
      }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  }

  function layoutAndRedraw() {
    applyTileLayout();
    redrawCanvas();
  }

  return {
    redrawCanvas,
    startAnimationLoop,
    layoutAndRedraw,
  };
}


src\hooks\useClickLock.ts
import { ref } from 'vue';

export function useClickLock() {
  const locked = ref(false);

  function isLocked() {
    return locked.value;
  }

  function lock() {
    locked.value = true;
  }

  function unlock() {
    locked.value = false;
  }

  return {
    isLocked,
    lock,
    unlock,
  };
}


src\hooks\useDebouncedRedraw.ts
export function useDebouncedRedraw(layoutAndRedraw: () => void, delay = 100) {
  let timeout: ReturnType<typeof setTimeout> | null = null;

  function debouncedRedraw() {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => {
      layoutAndRedraw();
    }, delay);
  }

  return {
    debouncedRedraw,
  };
}


src\hooks\useFormattedTime.ts
import { computed, type Ref } from 'vue';

export function useFormattedTime(seconds: Ref<number>) {
  return computed(() => {
    const totalSeconds = seconds.value;
    const hrs = Math.floor(totalSeconds / 3600);
    const mins = Math.floor((totalSeconds % 3600) / 60);
    const secs = totalSeconds % 60;

    const padded = (n: number) => String(n).padStart(2, '0');
    const secsFormatted = Number.isInteger(secs) ? padded(secs) : (secs < 10 ? '0' : '') + secs.toFixed(1);

    if (hrs > 0) {
      return `${padded(hrs)}:${padded(mins)}:${secsFormatted}`;
    }
    return `${padded(mins)}:${secsFormatted}`;
  });
}


src\hooks\useGameOverChecker.ts
import type { Tile } from '@/components/GameCanvas/GameCanvas.types';
import type { Ref } from 'vue';

export function useGameOverChecker(tiles: Ref<Tile[]>) {
  function checkIfGameOver(): boolean {
    return tiles.value.length > 0 && tiles.value.every((tile) => tile.matched);
  }

  return {
    checkIfGameOver,
  };
}


src\hooks\useGamePersistence.ts
import type { GameState } from '@/components/GameCanvas/GameCanvas.types';
import { useGameStateStorage } from './useGameStateStorage';

export function useGamePersistence(seed: string, difficulty: number) {
  const { save, load, clear } = useGameStateStorage();

  function saveState(state: GameState) {
    save({
      dateStart: state.dateStart ?? new Date().toISOString(),
      tiles: state.tiles,
      elapsedSeconds: state.elapsedSeconds,
      moves: state.moves,
      seed: state.seed,
      difficulty: state.difficulty,
      matchedPairs: state?.matchedPairs ?? [],
      matchCount: state?.matchCount ?? 0,
      mismatchCount: state?.mismatchCount ?? 0,
    });
  }

  function loadState() {
    return load();
  }

  function clearState() {
    clear();
  }

  return {
    saveState,
    loadState,
    clearState,
  };
}


src\hooks\useGameStart.ts
import { generateShuffledTiles } from '@/shared/utils/generateTiles';
import { preloadImagesWithAwait } from '@/shared/utils/imageCache';
import { isDifficultyType } from '@/shared/utils/isDifficultyType';
import { ref } from 'vue';

export function useGameStart() {
  const isLoading = ref(false);
  const seed = ref('');
  const difficulty = ref<number>(1);

  async function startGame(payload: { seed: string; difficulty: number }) {
    localStorage.removeItem('memory-game-state');
    seed.value = payload.seed || Date.now().toString();

    if (isDifficultyType(payload.difficulty)) {
      difficulty.value = payload.difficulty;
    } else {
      console.error('Invalid difficulty type:', payload.difficulty);
    }

    const tiles = generateShuffledTiles(seed.value, difficulty.value);
    const imagesToPreload = tiles.map((t) => t.imagePath!).filter(Boolean);

    isLoading.value = true;

    await preloadImagesWithAwait(imagesToPreload);

    isLoading.value = false;
    return {
      seed: seed.value,
      difficulty: difficulty.value,
    };
  }

  return {
    isLoading,
    startGame,
  };
}


src\hooks\useGameStateStorage.ts
import type { GameState } from '@/components/GameCanvas/GameCanvas.types';
import { useLocalStorage } from './useLocalStorage';

const STORAGE_KEY = 'memory-game-state';

export function useGameStateStorage() {
  const { data: gameState, clear } = useLocalStorage<GameState | null>(STORAGE_KEY, null);

  function save(state: GameState) {
    gameState.value = {
      dateStart: state.dateStart ?? new Date().toISOString(),
      tiles: state.tiles,
      elapsedSeconds: state.elapsedSeconds,
      moves: state.moves,
      seed: state.seed,
      difficulty: state.difficulty,
      matchedPairs: state?.matchedPairs ?? [],
      matchCount: state?.matchCount ?? 0,
      mismatchCount: state?.mismatchCount ?? 0,
    };
  }
  function load(): GameState | null {
    return gameState.value;
  }

  return {
    gameState,
    save,
    load,
    clear,
  };
}


src\hooks\useLocalStorage.ts
import { ref, watch } from 'vue';

export function useLocalStorage<T>(key: string, defaultValue: T) {
  const data = ref<T>(defaultValue);

  const raw = localStorage.getItem(key);
  if (raw) {
    try {
      data.value = JSON.parse(raw);
    } catch (e) {
      console.warn(`Cannot parse data from localStorage under key '${key}':`, e);
    }
  }

  watch(
    data,
    (newVal) => {
      localStorage.setItem(key, JSON.stringify(newVal));
    },
    { deep: true }
  );

  function clear() {
    localStorage.removeItem(key);
    data.value = defaultValue;
  }

  return {
    data,
    clear,
  };
}


src\hooks\useMouseCanvasPosition.ts
import type { Ref } from 'vue';

export function useMouseCanvasPosition(canvasRef: Ref<HTMLCanvasElement | null>) {
  const getMousePosition = (event: MouseEvent | TouchEvent) => {
    const canvas = canvasRef.value;
    if (!canvas) return { x: 0, y: 0 };

    const rect = canvas.getBoundingClientRect();

    const clientX = event instanceof TouchEvent ? event.touches[0].clientX : event.clientX;
    const clientY = event instanceof TouchEvent ? event.touches[0].clientY : event.clientY;

    return {
      x: clientX - rect.left,
      y: clientY - rect.top,
    };
  };

  return { getMousePosition };
}


src\hooks\useMouseTileHover.ts
import type { Tile } from '@/components/GameCanvas/GameCanvas.types';
import { ref, type Ref } from 'vue';
import { useThrottledDraw } from './useThrottledDraw';

export function useMouseTileHover(
  canvasRef: Ref<HTMLCanvasElement | null>,
  tiles: Ref<Tile[]>,
  tileSize: Ref<number>,
  getMousePosition: (e: MouseEvent | TouchEvent) => { x: number; y: number }
) {
  const hoveredTileId = ref<number | null>(null);
  const mouseX = ref(0);
  const mouseY = ref(0);

  const { triggerDraw } = useThrottledDraw(canvasRef, tiles, mouseX, mouseY, hoveredTileId, tileSize);

  function handleMouseMove(e: MouseEvent | TouchEvent) {
    const { x, y } = getMousePosition(e);
    mouseX.value = x;
    mouseY.value = y;

    const hovered = tiles.value.find(
      (tile) => x >= tile.x && x <= tile.x + tileSize.value && y >= tile.y && y <= tile.y + tileSize.value && !tile.matched && !tile.flipped
    );

    hoveredTileId.value = hovered?.id ?? null;

    if (canvasRef.value) {
      canvasRef.value.style.cursor = hoveredTileId.value !== null ? 'pointer' : 'default';
    }

    triggerDraw();
  }

  return {
    hoveredTileId,
    mouseX,
    mouseY,
    handleMouseMove,
  };
}


src\hooks\useResizeObserver.ts
import { onUnmounted, watch, type Ref } from 'vue';

export function useResizeObserver(targetRef: Ref<HTMLElement | null>, callback: () => void) {
  let observer: ResizeObserver | null = null;

  watch(
    targetRef,
    (element) => {
      if (!element) return;

      observer = new ResizeObserver(() => {
        callback();
      });
      observer.observe(element);
    },
    { immediate: true }
  );

  onUnmounted(() => {
    if (observer && targetRef.value) {
      observer.unobserve(targetRef.value);
    }
    observer = null;
  });
}


src\hooks\useSoundEffects.ts
import { sounds } from '@/shared/sounds/sounds';

export function useSoundEffects() {
  return {
    playFlip: () => {
      sounds.flip.play();
      return Promise.resolve();
    },
    playMatch: () => {
      sounds.match.play();
      return Promise.resolve();
    },
    playFail: () => {
      sounds.fail.play();
      return Promise.resolve();
    },
    playWin: () => {
      sounds.win.play();
      return Promise.resolve();
    },
  };
}


src\hooks\useThrottledDraw.ts
import type { Tile } from '@/components/GameCanvas/GameCanvas.types';
import { drawBoard } from '@/shared/utils/canvasRenderer';
import type { Ref } from 'vue';
import { ref, watchEffect } from 'vue';

export function useThrottledDraw(
  canvasRef: Ref<HTMLCanvasElement | null>,
  tiles: Ref<Tile[]>,
  mouseX: Ref<number>,
  mouseY: Ref<number>,
  hoveredTileId: Ref<number | null>,
  tileSize: Ref<number>
) {
  const needsRedraw = ref(false);
  let animationFrameId: number | null = null;

  function triggerDraw() {
    if (!needsRedraw.value) {
      needsRedraw.value = true;
      scheduleDraw();
    }
  }

  function scheduleDraw() {
    if (animationFrameId !== null) return;
    animationFrameId = requestAnimationFrame(() => {
      const canvas = canvasRef.value;
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      drawBoard(ctx, canvas, tiles.value, { x: mouseX.value, y: mouseY.value }, hoveredTileId.value, tileSize.value);

      needsRedraw.value = false;
      animationFrameId = null;
    });
  }

  watchEffect(() => {
    triggerDraw();
  });

  return {
    triggerDraw,
  };
}


src\hooks\useTileEngine.ts
import type { Tile } from '@/components/GameCanvas/GameCanvas.types';
import type { Ref } from 'vue';

export function useTileEngine(tiles: Ref<Tile[]>, tileSize: Ref<number>) {
  function getTileAt(x: number, y: number): Tile | null {
    return (
      tiles.value.find((tile) => {
        return x >= tile.x && x <= tile.x + tileSize.value && y >= tile.y && y <= tile.y + tileSize.value && !tile.flipped && !tile.matched;
      }) ?? null
    );
  }

  function isMatchByName(tileA: Tile, tileB: Tile): boolean {
    return tileA.name === tileB.name;
  }

  return {
    getTileAt,
    isMatchByName,
  };
}


src\hooks\useTileInteractions.ts
import type { Tile } from '@/components/GameCanvas/GameCanvas.types';
import { animateFlip } from '@/shared/utils/animationUtils';
import { drawBoard } from '@/shared/utils/canvasRenderer';
import { handleMatchPair } from '@/shared/utils/handlers/handleMatchPair';
import { handleMismatchPair } from '@/shared/utils/handlers/handleMismatchPair';
import { useGameStore } from '@/stores/useGameStore';
import type { Ref } from 'vue';
import { ref } from 'vue';
import { useClickLock } from './useClickLock';
import { useGameOverChecker } from './useGameOverChecker';
import { useSoundEffects } from './useSoundEffects';
import { useTileEngine } from './useTileEngine';

interface TileInteractionCallbacks {
  onGameOver: () => void;
  onMatch?: (a: Tile, b: Tile) => void;
  onMismatch?: (a: Tile, b: Tile) => void;
}

export function useTileInteractions(
  canvasRef: Ref<HTMLCanvasElement | null>,
  tiles: Ref<Tile[]>,
  mouseX: Ref<number>,
  mouseY: Ref<number>,
  hoveredTileId: Ref<number | null>,
  callbacks: TileInteractionCallbacks,
  tileSize: Ref<number>
) {
  const { onGameOver, onMatch, onMismatch } = callbacks;

  const flippedTiles = ref<Tile[]>([]);
  const gameOver = ref(false);
  const engine = useTileEngine(tiles, tileSize);
  const { playFlip, playMatch, playFail, playWin } = useSoundEffects();
  const { isLocked, lock, unlock } = useClickLock();
  const { checkIfGameOver } = useGameOverChecker(tiles);
  const gameStore = useGameStore();

  async function flipAndRender(tile: Tile, canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {
    await animateFlip(tile, canvas, tileSize.value, { reverse: true });
    tile.flipped = true;
    flippedTiles.value.push(tile);
    drawBoard(ctx, canvas, tiles.value, { x: mouseX.value, y: mouseY.value }, hoveredTileId.value, tileSize.value);
    await playFlip();
  }

  async function handleClick(e: MouseEvent | TouchEvent) {
    if (isLocked() || gameOver.value) return;

    const canvas = canvasRef.value;
    const ctx = canvas?.getContext('2d');
    if (!canvas || !ctx) return;

    const rect = canvas.getBoundingClientRect();
    const clientX = e instanceof TouchEvent ? e.changedTouches[0].clientX : e.clientX;
    const clientY = e instanceof TouchEvent ? e.changedTouches[0].clientY : e.clientY;
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    const tile = engine.getTileAt(x, y);
    if (!tile || tile.flipped || tile.matched || flippedTiles.value.length >= 2) return;

    lock();

    await flipAndRender(tile, canvas, ctx);

    if (flippedTiles.value.length === 2) {
      gameStore.incrementMoves();
      const [a, b] = flippedTiles.value;

      if (engine.isMatchByName(a, b)) {
        await handleMatchPair(a, b, {
          playMatch,
          checkIfGameOver,
          playWin,
          onGameOver,
          onMatch,
          setGameOver: (v) => (gameOver.value = v),
          unlock,
        });
        flippedTiles.value = [];
      } else {
        await handleMismatchPair(a, b, {
          playFail,
          drawBoard: () => {
            drawBoard(ctx, canvas, tiles.value, { x: mouseX.value, y: mouseY.value }, hoveredTileId.value, tileSize.value);
          },
          onMismatch,
          unlock,
        });
        flippedTiles.value = [];
      }
    } else {
      unlock();
    }
  }

  function resetInteractions() {
    flippedTiles.value = [];
    unlock();
    gameOver.value = false;
    gameStore.setGameOver(false);
  }

  function isGameOver() {
    return gameOver.value;
  }

  return {
    handleClick,
    resetInteractions,
    isGameOver,
  };
}


src\hooks\useTimer.ts
import { ref } from 'vue';

import { useGameStore } from '@/stores/useGameStore';

export function useTimer(onBackup?: () => void) {
  const elapsed = ref(0);
  let interval: number | null = null;
  const gameStore = useGameStore();

  function start() {
    if (interval) return;
    interval = window.setInterval(() => {
      gameStore.incrementTime();
      onBackup?.();
    }, 1000);
  }

  function stop() {
    if (interval) {
      clearInterval(interval);
      interval = null;
    }
  }

  function reset() {
    stop();
    gameStore.elapsed = 0;
  }

  return {
    elapsed,
    start,
    stop,
    reset,
  };
}


src\i18n\locales.ts
export interface LocaleOption {
  code: string;
  label: string;
  flag: string;
}

export const localeOptions: LocaleOption[] = [
  { code: 'pl', label: 'Polski', flag: '/icons/flags/pl.svg' },
  { code: 'en', label: 'English', flag: '/icons/flags/en.svg' },
];


src\shared\components\Button\Button.model.ts
import type { VNode } from 'vue';

export enum ButtonVariant {
  PRIMARY = 'primary',
  SECONDARY = 'secondary',
  TERTIARY = 'tertiary',
  ROUND = 'round',
}

export type TypeButton = 'button' | 'submit' | 'reset';
export type IButtonVariantTypes = 'primary' | 'secondary' | 'tertiary' | 'round';

export interface IButtonComponent {
  id?: string;
  key?: string;
  name?: string;
  type?: TypeButton;
  children?: string | VNode | VNode[];
  handleClick?: (e: MouseEvent) => void;
  active?: boolean;
  className?: string | string[] | Record<string, boolean>;
  tooltip?: string;
  variant?: IButtonVariantTypes;
  buttonsConfig?: IButtonComponent[];
  configCustomClass?: string;
  size?: 'xs' | 'sm' | 'lg';
  selected?: boolean;
  disabled?: boolean;
  [key: string]: any;
}


src\shared\components\Button\Button.spec.ts
import { mount } from '@vue/test-utils';
import { OhVueIcon } from 'oh-vue-icons';
import { describe, expect, it } from 'vitest';
import Button from './Button.vue';

describe('Button.vue', () => {
  it('renders slot content', () => {
    const wrapper = mount(Button, {
      slots: { default: 'Click me' },
    });
    expect(wrapper.text()).toBe('Click me');
  });

  it('emits click event when clicked', async () => {
    const wrapper = mount(Button, {
      slots: { default: 'Click' },
    });
    await wrapper.trigger('click');
    expect(wrapper.emitted()).toHaveProperty('click');
  });

  it('renders icon passed via children', () => {
    const wrapper = mount(Button, {
      props: {
        buttonsConfig: [
          {
            id: 'test',
            children: h(OhVueIcon, { name: 'fa-check' }),
          },
        ],
      },
    });

    expect(wrapper.find('svg').exists()).toBe(true);
  });

  it('accepts aria-label and type attributes', () => {
    const wrapper = mount(Button, {
      attrs: {
        'aria-label': 'Confirm',
        type: 'submit',
      },
      slots: { default: 'Submit' },
    });
    expect(wrapper.attributes('aria-label')).toBe('Confirm');
    expect(wrapper.attributes('type')).toBe('submit');
  });
});


src\shared\components\Button\Button.vue
<template>
  <template v-if="!props.buttonsConfig?.length">
    <button
      :type="props.type || 'button'"
      :class="buttonClasses"
      :disabled="props.disabled"
      :aria-label="computedAriaLabel ?? ''"
      v-bind="restAttrs"
      @click="props.handleClick"
    >
      <slot>
        <template v-if="(props?.name ?? '').length > 0">
          {{ $t(props.name || '') }}
        </template>
      </slot>
    </button>
  </template>

  <template v-else>
    <div :class="props.configCustomClass ?? 'flex gap-8'">
      <button
        v-for="(btn, i) in props.buttonsConfig"
        :key="btn.id || btn.name || `btn-${i}`"
        :type="btn.type || 'button'"
        :class="getButtonClasses(btn)"
        :disabled="btn.disabled ?? false"
        :aria-label="getAriaLabel(btn)"
        v-bind="getRestAttrs(btn)"
        @click="btn.handleClick"
      >
        <template v-if="btn.name">
          {{ $t(btn.name) }}
        </template>
        <template v-else-if="btn.children">
          <component :is="btn.children" />
        </template>
      </button>
    </div>
  </template>
</template>

<script setup lang="ts">
import { isValidAttribute } from '@/shared/utils/safeAttributes';
import { clsx } from 'clsx';
import { computed, useAttrs } from 'vue';
import { useI18n } from 'vue-i18n';
import type { IButtonComponent } from './Button.model';

const props = defineProps<IButtonComponent>();
const restAttrs = useAttrs();
const { t } = useI18n();

const computedAriaLabelFallback = computed(() => ((props.name ?? '').length > 0 ? t(props.name || '') : 'Unnamed Button'));

const computedAriaLabel = computed(() => {
  const hasLabelledBy = 'aria-labelledby' in restAttrs && !!restAttrs['aria-labelledby'];
  return !hasLabelledBy ? String(restAttrs['aria-label'] ?? computedAriaLabelFallback.value) : '';
});

const getButtonClasses = (btn: IButtonComponent) => {
  const variantClasses = {
    primary: 'primary',
    secondary: 'secondary',
    tertiary: 'tertiary',
    round: 'round rounded-full',
  };

  const sizeClasses = {
    xs: btn.variant === 'round' ? 'text-sm h-6 w-6' : 'text-xs px-1 py-1',
    sm: btn.variant === 'round' ? 'text-base h-8 w-8' : 'text-sm px-3 py-2',
    lg: btn.variant === 'round' ? 'text-xl h-12 w-12' : 'text-base px-4 py-3',
  };

  return clsx([
    'button-component',
    variantClasses[btn.variant || 'primary'],
    sizeClasses[btn.size || 'sm'],
    btn.disabled ? 'bg-gray text-disabled cursor-not-allowed' : '',
    typeof btn.className === 'string' ? btn.className : clsx(btn.className),
    { active: btn.active },
  ]);
};

const buttonClasses = computed(() => getButtonClasses(props));

const getAriaLabel = (btn: IButtonComponent) => {
  const hasLabelledBy = 'aria-labelledby' in btn && !!btn['aria-labelledby'];
  return !hasLabelledBy ? (btn['aria-label'] ?? (btn.name ? t(btn.name) : 'Unnamed Button')) : undefined;
};

const getRestAttrs = (btn: IButtonComponent) => {
  const {
    id,
    key,
    name,
    type,
    handleClick,
    active,
    className,
    tooltip,
    variant,
    buttonsConfig,
    configCustomClass,
    size,
    selected,
    disabled,
    children,
    ...rest
  } = btn;

  const safeAttrs: Record<string, any> = {};
  for (const [k, v] of Object.entries(rest)) {
    if (isValidAttribute(k)) {
      safeAttrs[k] = v;
    }
  }
  return safeAttrs;
};
</script>


src\shared\components\CollapsiblePanel\CollapsiblePanel.model.ts
export interface ICollapsiblePanel {
  title: string;
  size?: 'xs' | 'sm' | 'lg';
  [key: string]: any;
}


src\shared\components\CollapsiblePanel\CollapsiblePanel.spec.ts
import { mount } from '@vue/test-utils';
import { describe, expect, it } from 'vitest';
import CollapsiblePanel from './CollapsiblePanel.vue';

describe('CollapsiblePanel.vue', () => {
  it('renders the title and default slot', async () => {
    const wrapper = mount(CollapsiblePanel, {
      props: {
        title: 'Test Panel',
      },
      slots: {
        default: '<div class="slot-content">Panel Content</div>',
      },
    });

    expect(wrapper.text()).toContain('Test Panel');

    expect(wrapper.find('.slot-content').isVisible()).toBe(false);

    await wrapper.find('button').trigger('click');
    expect(wrapper.find('.slot-content').exists()).toBe(true);
  });

  it('applies size classes correctly', () => {
    const wrapper = mount(CollapsiblePanel, {
      props: {
        title: 'Sized Panel',
        size: 'lg',
      },
    });

    expect(wrapper.classes()).toContain('lg');
  });
});


src\shared\components\CollapsiblePanel\CollapsiblePanel.vue
<template>
  <div class="collapsible" :class="props?.size ?? 'sm'">
    <Button className="collapsible-header" :size="props?.size ?? 'sm'" :handleClick="() => (isOpen = !isOpen)">
      <span>{{ props?.title ?? '' }}</span>
      <VIcon name="fa-chevron-down" :class="{ rotated: isOpen }" class="arrow-icon" />
    </Button>

    <transition name="fade">
      <div v-show="isOpen" class="collapsible-content">
        <slot />
      </div>
    </transition>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import type { ICollapsiblePanel } from './CollapsiblePanel.model';
import './CollapsiblePanel.scss';

const props = defineProps<ICollapsiblePanel>();
const isOpen = ref(false);
</script>


src\shared\components\InputField\InputField.spec.ts
import { mount } from '@vue/test-utils';
import { describe, expect, it } from 'vitest';
import InputField from './InputField.vue';

describe('InputField.vue', () => {
  it('renderuje etykietê, placeholder i opis', () => {
    const wrapper = mount(InputField, {
      props: {
        id: 'test-id',
        label: 'Testowa etykieta',
        placeholder: 'Wpisz coœ...',
        description: 'Opis pola',
        describedby: 'opis-id',
        modelValue: '',
      },
    });

    expect(wrapper.find('label').text()).toBe('Testowa etykieta');
    expect(wrapper.find('input').attributes('placeholder')).toBe('Wpisz coœ...');
    expect(wrapper.find('p.input-description').exists()).toBe(true);
    expect(wrapper.find('p.input-description').text()).toBe('Opis pola');
    expect(wrapper.find('input').attributes('aria-describedby')).toBe('opis-id');
  });

  it('wyœwietla wartoœæ z modelValue', () => {
    const wrapper = mount(InputField, {
      props: {
        id: 'test-id',
        label: 'Test',
        modelValue: 'pocz¹tkowa wartoœæ',
      },
    });

    const input = wrapper.find('input');
    expect((input.element as HTMLInputElement).value).toBe('pocz¹tkowa wartoœæ');
  });

  it('emituje update:modelValue po edycji', async () => {
    const wrapper = mount(InputField, {
      props: {
        id: 'test-id',
        label: 'Test',
        modelValue: '',
      },
    });

    const input = wrapper.find('input');
    await input.setValue('nowa wartoœæ');

    expect(wrapper.emitted()['update:modelValue']).toBeTruthy();
    expect(wrapper.emitted()['update:modelValue']![0]).toEqual(['nowa wartoœæ']);
  });

  it('nie renderuje opisu, jeœli nie zosta³ podany', () => {
    const wrapper = mount(InputField, {
      props: {
        id: 'test-id',
        label: 'Bez opisu',
        modelValue: '',
      },
    });

    expect(wrapper.find('.input-description').exists()).toBe(false);
  });
});


src\shared\components\InputField\InputField.vue
<template>
  <div class="input-field">
    <label :for="id" class="input-label">{{ label }}</label>
    <input :id="id" type="text" :placeholder="placeholder" :aria-describedby="describedby" v-model="inputValue" class="input-element" />
    <p v-if="description" :id="describedby" class="input-description">{{ description }}</p>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';

const props = defineProps<{
  id: string;
  label: string;
  placeholder?: string;
  description?: string;
  modelValue: string;
  describedby?: string;
}>();

const emit = defineEmits(['update:modelValue']);

const inputValue = computed({
  get: () => props.modelValue,
  set: (value: string) => emit('update:modelValue', value),
});
</script>

<style scoped src="./InputField.scss" />


src\shared\components\LazyImage\LazyImage.spec.ts
import { mount } from '@vue/test-utils';
import { describe, expect, it, vi } from 'vitest';
import LazyImage from './LazyImage.vue';

describe('LazyImage.vue', () => {
  it('renders a placeholder initially', () => {
    const wrapper = mount(LazyImage, {
      props: { src: 'https://example.com/image.jpg', alt: 'Example Image' },
    });

    expect(wrapper.find('[data-testid="lazy-placeholder"]').exists()).toBe(true);
    expect(wrapper.find('img').classes()).toContain('lazyloading');
  });

  it('displays default logo if src is null or error occurs', async () => {
    const wrapper = mount(LazyImage, {
      props: { src: null, alt: 'No Image' },
    });

    const img = wrapper.find('img');
    expect(img.attributes('src')).toContain('No_image_available.svg');

    await img.trigger('error');
    expect(img.attributes('src')).toContain('No_image_available.svg');
  });

  it('sets alt and id attributes properly', () => {
    const wrapper = mount(LazyImage, {
      props: { id: 'test-img', src: 'https://example.com/image.jpg', alt: 'Alt Text' },
    });

    const img = wrapper.find('img');
    expect(img.attributes('alt')).toBe('Alt Text');
    expect(img.attributes('id')).toBe('test-img');
  });

  it('calls onClick handler when image is clicked', async () => {
    const onClick = vi.fn();
    const wrapper = mount(LazyImage, {
      props: { src: 'https://example.com/image.jpg', onClick },
    });

    await wrapper.find('img').trigger('click');
    expect(onClick).toHaveBeenCalled();
  });

  it('adds lazyloaded class when image loads', async () => {
    const wrapper = mount(LazyImage, {
      props: { src: 'https://example.com/image.jpg' },
    });

    await wrapper.find('img').trigger('load');
    expect(wrapper.find('img').classes()).toContain('lazyloaded');
  });
});


src\shared\components\LazyImage\LazyImage.vue
<template>
  <div v-if="!loaded" class="lazy-placeholder" data-testid="lazy-placeholder" aria-hidden="true" />
  <img
    :id="id"
    loading="lazy"
    :src="error || !src ? defaultLogo : src"
    :alt="alt"
    ref="imgRef"
    :class="clsx('img-fluid', className ?? '', { lazyloaded: loaded, lazyloading: !loaded })"
    @load="onLoad"
    @error="onError"
    @click="onClick"
  />
</template>

<script setup lang="ts">
import { clsx } from 'clsx';
import { onMounted, onUnmounted, ref } from 'vue';

defineProps<{
  id?: string;
  className?: string;
  src?: string | null;
  alt?: string;
  onClick?: () => void;
}>();

const defaultLogo = 'https://upload.wikimedia.org/wikipedia/commons/a/ac/No_image_available.svg';

const loaded = ref(false);
const error = ref(false);
const imgRef = ref<HTMLImageElement | null>(null);

function onLoad() {
  loaded.value = true;
}
function onError() {
  error.value = true;
}

onMounted(() => {
  const observer = new IntersectionObserver(
    ([entry]) => {
      if (entry.isIntersecting) {
        observer.disconnect();
      }
    },
    { threshold: 0.1 }
  );

  if (imgRef.value) observer.observe(imgRef.value);
  onUnmounted(() => observer.disconnect());
});
</script>

<style scoped src="./LazyImage.scss" />


src\shared\components\SelectField\SelectField.spec.ts
import { mount } from '@vue/test-utils';
import { describe, expect, it } from 'vitest';
import SelectField from './SelectField.vue';

const options = [
  { id: 1, displayName: 'Opcja 1' },
  { id: 2, displayName: 'Opcja 2' },
  { id: 3, displayName: 'Opcja 3' },
];

describe('SelectField.vue', () => {
  it('renderuje label, select i description', () => {
    const wrapper = mount(SelectField, {
      props: {
        id: 'select-id',
        label: 'Wybierz opcjê',
        description: 'Opis pola',
        describedby: 'opis-id',
        modelValue: 2,
        options,
      },
    });

    expect(wrapper.find('label').text()).toBe('Wybierz opcjê');
    expect(wrapper.find('select').attributes('aria-describedby')).toBe('opis-id');
    expect(wrapper.findAll('option')).toHaveLength(3);
    expect(wrapper.find('p.select-description').text()).toBe('Opis pola');
  });

  it('wyœwietla poprawn¹ pocz¹tkow¹ wartoœæ selecta', () => {
    const wrapper = mount(SelectField, {
      props: {
        id: 'select-id',
        label: 'Opcje',
        modelValue: 3,
        options,
      },
    });

    const select = wrapper.find('select');
    expect((select.element as HTMLSelectElement).value).toBe('3');
  });

  it('emituje update:modelValue przy zmianie wartoœci', async () => {
    const wrapper = mount(SelectField, {
      props: {
        id: 'select-id',
        label: 'Opcje',
        modelValue: 1,
        options,
      },
    });

    const select = wrapper.find('select');
    await select.setValue('2');

    expect(wrapper.emitted()['update:modelValue']).toBeTruthy();
    expect(wrapper.emitted()['update:modelValue']![0]).toEqual([2]);
  });

  it('nie renderuje opisu, jeœli nie jest podany', () => {
    const wrapper = mount(SelectField, {
      props: {
        id: 'select-id',
        label: 'Bez opisu',
        modelValue: 1,
        options,
      },
    });

    expect(wrapper.find('.select-description').exists()).toBe(false);
  });
});


src\shared\components\SelectField\SelectField.vue
<template>
  <div class="select-field">
    <label :for="id" class="select-label">{{ label ?? '' }}</label>
    <select :id="id" :aria-describedby="describedby" v-model.number="selectValue" class="select-element">
      <option v-for="option in options" :key="option.id" :value="option.id" class="select-option">
        {{ option.displayName }}
      </option>
    </select>
    <p v-if="description" :id="describedby" class="select-description">{{ description }}</p>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';

const props = defineProps<{
  id: string;
  label: string;
  description?: string;
  describedby?: string;
  options: { id: number | string; displayName: string }[];
  modelValue: number;
}>();

const emit = defineEmits(['update:modelValue']);

const selectValue = computed({
  get: () => props.modelValue,
  set: (value: number) => emit('update:modelValue', value),
});
</script>

<style scoped src="./SelectField.scss" />


src\shared\components\Spinner\Spinner.spec.ts
import Spinner from '@/shared/components/Spinner/Spinner.vue';
import { mount } from '@vue/test-utils';
import { describe, expect, it } from 'vitest';

describe('Spinner.vue', () => {
  it('renderuje domyœlny spinner z poprawnymi domyœlnymi propsami i atrybutami', () => {
    const wrapper = mount(Spinner);
    const outerDiv = wrapper.find('.spinner');
    expect(outerDiv.exists()).toBe(true);
    expect(outerDiv.attributes('role')).toBe('status');
    expect(outerDiv.attributes('aria-busy')).toBe('true');
    expect(outerDiv.attributes('aria-label')).toBe('Loading...');
    const text = wrapper.find('.spinner-text');
    expect(text.exists()).toBe(true);
    expect(text.text()).toBe('Loading...');
    const loader = wrapper.find('.spinner-loader');
    expect(loader.exists()).toBe(true);
    const style = loader.attributes('style');
    expect(style).toContain('width: 40px');
    expect(style).toContain('height: 40px');
    expect(style).toContain('border: 4px solid rgb(0, 123, 255)');
    expect(style).toContain('border-top-color: transparent');
    expect(style).toContain('border-radius: 50%');
  });

  it('renderuje spinner z rozmiarem "small" i odpowiednio aktualizuje style', () => {
    const wrapper = mount(Spinner, {
      props: { size: 'small' },
    });
    const loaderStyle = wrapper.get('.spinner-loader').attributes('style');
    expect(loaderStyle).toContain('width: 20px');
    expect(loaderStyle).toContain('height: 20px');
    expect(loaderStyle).toContain('border: 4px solid rgb(0, 123, 255)');
  });

  it('renderuje spinner z rozmiarem "large" i odpowiednio aktualizuje style', () => {
    const wrapper = mount(Spinner, {
      props: { size: 'large' },
    });
    const loaderStyle = wrapper.get('.spinner-loader').attributes('style');
    expect(loaderStyle).toContain('width: 60px');
    expect(loaderStyle).toContain('height: 60px');
    expect(loaderStyle).toContain('border: 4px solid rgb(0, 123, 255)');
  });

  it('ustawia niestandardowy kolor obramowania gdy prop "color" jest podany', () => {
    const wrapper = mount(Spinner, {
      props: { color: '#ff0000' },
    });
    const loaderStyle = wrapper.get('.spinner-loader').attributes('style');
    expect(loaderStyle).toContain('width: 40px');
    expect(loaderStyle).toContain('height: 40px');
    expect(loaderStyle).toContain('border: 4px solid rgb(255, 0, 0)');
    expect(loaderStyle).toContain('border-top-color: transparent');
  });

  it('ustawia niestandardowy ariaLabel i odzwierciedla go w atrybucie aria-label oraz tekœcie', () => {
    const wrapper = mount(Spinner, {
      props: { ariaLabel: 'Please wait' },
    });
    const outerDiv = wrapper.get('.spinner');
    expect(outerDiv.attributes('aria-label')).toBe('Please wait');
    expect(wrapper.get('.spinner-text').text()).toBe('Please wait');
    expect(outerDiv.attributes('role')).toBe('status');
    expect(outerDiv.attributes('aria-busy')).toBe('true');
  });

  it('zawiera poprawne atrybuty ARIA dla dostêpnoœci', () => {
    const wrapper = mount(Spinner);
    const outerDiv = wrapper.get('.spinner');
    expect(outerDiv.attributes('role')).toBe('status');
    expect(outerDiv.attributes('aria-busy')).toBe('true');
    expect(outerDiv.attributes('aria-label')).toBe('Loading...');
  });
});


src\shared\components\Spinner\Spinner.vue
<template>
  <div role="status" :aria-label="ariaLabel" aria-busy="true" class="spinner">
    <div class="spinner-inner">
      <div class="spinner-loader" :style="loaderStyle" />
      <p class="spinner-text">{{ ariaLabel }}</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';

interface SpinnerProps {
  size?: 'small' | 'medium' | 'large';
  color?: string;
  ariaLabel?: string;
}

const props = withDefaults(defineProps<SpinnerProps>(), {
  size: 'medium',
  color: '#007bff',
  ariaLabel: 'Loading...',
});

const sizes = {
  small: '20px',
  medium: '40px',
  large: '60px',
};

const loaderStyle = computed(() => ({
  width: sizes[props.size],
  height: sizes[props.size],
  border: `4px solid ${props.color}`,
  borderTopColor: 'transparent',
  borderRadius: '50%',
}));
</script>

<style scoped src="./Spinner.scss" />


src\shared\sounds\sounds.ts
import { Howl } from 'howler';

export const sounds = {
  flip: new Howl({ src: ['/sounds/flip.mp3'] }),
  match: new Howl({ src: ['/sounds/match.mp3'] }),
  fail: new Howl({ src: ['/sounds/fail.mp3'] }),
  win: new Howl({ src: ['/sounds/win.mp3'] }),
};


src\shared\types\difficultyTypes.ts
export type DifficultyType = 'easy' | 'medium' | 'hard';


src\shared\utils\animationUtils.ts
import { colors } from '@/components/GameCanvas/GameCanvas.const';
import type { Tile } from '@/components/GameCanvas/GameCanvas.types';
import { drawTileWithFlip } from './canvasRenderer';

export function animateFlip(tile: Tile, canvas: HTMLCanvasElement, size = 100, options: { reverse?: boolean } = {}): Promise<void> {
  return new Promise((resolve) => {
    const ctx = canvas.getContext('2d');
    if (!ctx) return resolve();

    const frames = 10;
    const { x, y } = tile;
    let frame = 0;

    function step() {
      if (!ctx) return resolve();
      const progress = options.reverse ? 1 - frame / frames : frame / frames;
      ctx.clearRect(x - 2, y - 2, size + 4, size + 4);
      drawTileWithFlip(ctx, tile, progress, size);

      if (++frame <= frames) {
        requestAnimationFrame(step);
      } else {
        resolve();
      }
    }

    step();
  });
}

export function drawBoardWithSingleTile(tile: Tile, progress: number, tiles: Tile[], canvas: HTMLCanvasElement): void {
  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = colors.lightGray;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (const t of tiles) {
    if (t.id === tile.id) {
      drawTileWithFlip(ctx, t, progress);
    } else {
      drawTileWithFlip(ctx, t, t.flipped || t.matched ? 1 : 0);
    }
  }
}


src\shared\utils\canvasRenderer.ts
import { colors, RarityBorders, RarityColors } from '@/components/GameCanvas/GameCanvas.const';
import type { Tile } from '@/components/GameCanvas/GameCanvas.types';
import { preloadedImages } from '@/shared/utils/imageCache';
import { drawRoundedRect } from './drawRoundedRect';

function getAnimatedStrokeGradient(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  width: number,
  height: number,
  angle: number,
  baseColor: string
): CanvasGradient {
  const radiusX = width / 2;
  const radiusY = height / 2;
  const cx = x + radiusX;
  const cy = y + radiusY;

  const offsetX = Math.cos(angle) * radiusX;
  const offsetY = Math.sin(angle) * radiusY;

  const gradient = ctx.createLinearGradient(cx - offsetX, cy - offsetY, cx + offsetX, cy + offsetY);

  gradient.addColorStop(0, baseColor);
  gradient.addColorStop(0.5, 'white');
  gradient.addColorStop(1, baseColor);

  return gradient;
}

function drawTileFrame(ctx: CanvasRenderingContext2D, tile: Tile, tileWidth: number, tileHeight: number, isHovered: boolean) {
  const baseColor = RarityBorders[tile.rarity];
  const angle = tile.matched && tile.haloAngle !== undefined ? tile.haloAngle : 0;

  if (tile.matched && tile.haloAngle !== undefined) {
    ctx.strokeStyle = getAnimatedStrokeGradient(ctx, tile.x, tile.y, tileWidth, tileHeight, angle, baseColor);
  } else {
    ctx.strokeStyle = baseColor;
  }

  ctx.lineWidth = isHovered ? 8 : 5;
  drawRoundedRect(ctx, tile.x + 1, tile.y + 1, tileWidth - 2, tileHeight - 2, 10);
  ctx.stroke();
}

export function drawTileWithFlip(ctx: CanvasRenderingContext2D, tile: Tile, progress: number, size = 100) {
  const tileWidth = size;
  const tileHeight = size;

  const centerX = tile.x + tileWidth / 2;
  const centerY = tile.y + tileHeight / 2;

  ctx.save();
  ctx.translate(centerX, centerY);
  ctx.scale(1 - 2 * Math.abs(progress - 0.5), 1);
  ctx.translate(-centerX, -centerY);

  if (tile.flipped || tile.matched) {
    const gradient = ctx.createLinearGradient(tile.x, tile.y, tile.x + tileWidth, tile.y + tileHeight);
    gradient.addColorStop(0, RarityColors[tile.rarity]);
    gradient.addColorStop(1, colors.darkBlue);
    ctx.fillStyle = gradient;
    drawRoundedRect(ctx, tile.x, tile.y, tileWidth, tileHeight, 10);
    ctx.fill();

    if (tile.imagePath && progress > 0.5) {
      const img = preloadedImages[tile.imagePath];
      if (img && img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) {
        ctx.drawImage(img, tile.x + size * 0.1, tile.y + size * 0.1, size * 0.8, size * 0.8);
      }
    }

    ctx.strokeStyle = RarityBorders[tile.rarity];

    drawTileFrame(ctx, tile, tileWidth, tileHeight, false);

    ctx.fillStyle = colors.tonedBlack;
    const textSize = Math.floor(size * 0.07);
    ctx.font = `${textSize}px Roboto`;
    ctx.fillText(tile.name.split('|')[0], tile.x + size * 0.05, tile.y + size - size * 0.05);
  } else {
    ctx.fillStyle = colors.darkBlue;
    drawRoundedRect(ctx, tile.x, tile.y, tileWidth, tileHeight, 10);
    ctx.fill();
  }

  ctx.restore();
}

export function drawBoard(
  ctx: CanvasRenderingContext2D,
  canvas: HTMLCanvasElement,
  tiles: Tile[],
  mouse: { x: number; y: number },
  hoveredId: number | null,
  tileSize = 100,
  fadeStartTime?: Ref<number | null>
) {
  const now = Date.now();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = colors.lightGray;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  tiles.forEach((tile) => {
    const centerX = tile.x + tileSize / 2;
    const centerY = tile.y + tileSize / 2;
    const isHovered = hoveredId === tile.id;

    let alpha = 1;
    if (fadeStartTime?.value) {
      const elapsed = now - fadeStartTime.value;
      const fadeInDuration = 600; // ms
      alpha = Math.min(1, elapsed / fadeInDuration);
    }

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(centerX, centerY);
    ctx.translate(-centerX, -centerY);

    if (isHovered) {
      ctx.shadowColor = colors.shadowColor;
      ctx.shadowBlur = 16;
    } else {
      ctx.shadowBlur = 0;
    }

    if (tile.matched || tile.flipped) {
      const gradient = ctx.createLinearGradient(tile.x, tile.y, tile.x + tileSize, tile.y + tileSize);
      gradient.addColorStop(0, RarityColors[tile.rarity]);
      gradient.addColorStop(1, colors.darkBlue);
      ctx.fillStyle = gradient;
      drawRoundedRect(ctx, tile.x, tile.y, tileSize, tileSize, 10);
      ctx.fill();

      const img = preloadedImages[tile.imagePath!];
      if (img && img.complete && img.naturalWidth > 0) {
        const offsetX = (mouse.x - centerX) * 0.02;
        const offsetY = (mouse.y - centerY) * 0.02;
        ctx.drawImage(img, tile.x + tileSize * 0.1 + offsetX, tile.y + tileSize * 0.1 + offsetY, tileSize * 0.8, tileSize * 0.8);
      }

      ctx.strokeStyle = RarityBorders[tile.rarity];
      drawTileFrame(ctx, tile, tileSize, tileSize, isHovered);

      ctx.fillStyle = colors.lightGray;
      const textSize = Math.floor(tileSize * 0.08);
      ctx.font = `${textSize}px Roboto`;
      ctx.shadowColor = colors.gray;
      ctx.shadowBlur = 4;
      ctx.shadowOffsetX = 1;
      ctx.shadowOffsetY = 1;
      ctx.fillText(tile.name.split('|')[0], tile.x + tileSize * 0.05, tile.y + tileSize - tileSize * 0.05);
    } else {
      ctx.fillStyle = colors.darkBlue;
      drawRoundedRect(ctx, tile.x, tile.y, tileSize, tileSize, 10);
      ctx.fill();
    }

    ctx.restore();
  });
}


src\shared\utils\drawRoundedRect.ts
export function drawRoundedRect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
}


src\shared\utils\generateTiles.ts
import { weapons } from '@/components/GameCanvas/GameCanvas.const';
import type { Skin, Tile } from '@/components/GameCanvas/GameCanvas.types';
import { getRandomRarity } from './getRandomRarity';
import { preloadImagesSync } from './imageCache';

export const skins: Skin[] =
  weapons?.map((name, index) => ({
    id: index,
    name: name?.toUpperCase(),
    imagePath: `/images/weapons/${name.replace(/ /g, '_')}.png`,
    rarity: getRandomRarity(),
  })) ?? [];

preloadImagesSync(skins.map((skin) => skin.imagePath));

function xmur3(str: string): () => number {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function () {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= h >>> 16;
    return (h >>> 0) / 4294967296;
  };
}

function shuffleArray<T>(array: T[], seed: string): T[] {
  const rng = xmur3(seed);
  const copy = [...array];
  for (let i = copy.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [copy[i], copy[j]] = [copy[j], copy[i]];
  }
  return copy;
}

export const generateShuffledTiles = (seed: string, difficulty: number): Tile[] => {
  const tiles: Tile[] = [];
  const numPairs = difficulty === 1 ? 6 : difficulty === 2 ? 10 : 15;

  const selectedSkins = shuffleArray(skins, seed).slice(0, numPairs);

  selectedSkins.forEach((skin, index) => {
    const pairId = index;
    for (let i = 0; i < 2; i++) {
      tiles.push({
        id: tiles.length,
        name: skin.name,
        pairId,
        flipped: false,
        matched: false,
        x: 0,
        y: 0,
        rarity: skin.rarity,
        imagePath: skin.imagePath,
      });
    }
  });

  const shuffled = shuffleArray(tiles, seed);

  const cols = 6;
  const spacing = 110;
  shuffled.forEach((tile, index) => {
    const row = Math.floor(index / cols);
    const col = index % cols;
    tile.x = col * spacing + 20;
    tile.y = row * spacing + 20;
  });

  return shuffled;
};


src\shared\utils\getRandomRarity.ts
import { rarities } from '@/components/GameCanvas/GameCanvas.const';
import type { Rarity } from '@/components/GameCanvas/GameCanvas.types';

export const getRandomRarity = (): Rarity => {
  const index = Math.floor(Math.random() * rarities.length);
  return rarities[index];
};


src\shared\utils\imageCache.ts
export const preloadedImages: Record<string, HTMLImageElement> = {};

export function preloadImagesSync(paths: string[]) {
  paths.forEach((path) => {
    const lowerPath = path.toLowerCase();
    if (!preloadedImages[lowerPath]) {
      const img = new Image();
      img.src = path;

      img.onerror = () => {
        console.warn(`Image preload failed: ${path}`);
        delete preloadedImages[lowerPath];
      };

      preloadedImages[lowerPath] = img;
    }
  });
}

export async function preloadImagesWithAwait(paths: string[]) {
  const promises = paths.map((path) => {
    const lowerPath = path.toLowerCase();

    return new Promise<void>((resolve) => {
      if (preloadedImages[lowerPath]) {
        const img = preloadedImages[lowerPath];
        if (img.complete) return resolve();
        img.onload = () => resolve();
        img.onerror = () => {
          console.warn(`Image preload failed: ${path}`);
          delete preloadedImages[lowerPath];
          resolve();
        };
      } else {
        const img = new Image();
        img.src = path;
        preloadedImages[lowerPath] = img;

        if (img.complete) return resolve();

        img.onload = () => resolve();
        img.onerror = () => {
          console.warn(`Image preload failed: ${path}`);
          delete preloadedImages[lowerPath];
          resolve();
        };
      }
    });
  });

  await Promise.all(promises);
}


src\shared\utils\isDifficultyType.ts
export function isDifficultyType(difficulty: number): boolean {
  const validDifficulties: number[] = [1, 2, 3];
  return validDifficulties.includes(difficulty);
}


src\shared\utils\lightenColor.ts
export function lightenColor(hex: string, amount = 0.2): string {
  const clamp = (v: number) => Math.min(255, Math.max(0, v));
  const [r, g, b] = hex
    .replace('#', '')
    .match(/.{2}/g)!
    .map((c) => parseInt(c, 16));
  const lighter = [r, g, b].map((v) => clamp(Math.floor(v + (255 - v) * amount)));
  return `rgb(${lighter.join(',')})`;
}


src\shared\utils\safeAttributes.ts
export function isValidAttribute(attr: string): boolean {
  if (!attr || typeof attr !== 'string') return false;
  if (attr.trim() === '') return false;
  if (/["<>\\\s]/.test(attr)) return false;
  if (attr.startsWith('"')) return false;
  return true;
}


src\shared\utils\throttle.ts
export function throttle<T extends (...args: any[]) => any>(fn: T, limit = 30000): T {
  let lastCall = 0;
  let timeout: ReturnType<typeof setTimeout> | null = null;

  return function (...args: any[]) {
    const now = Date.now();
    if (now - lastCall >= limit) {
      lastCall = now;
      fn(...args);
    } else if (!timeout) {
      timeout = setTimeout(
        () => {
          lastCall = Date.now();
          fn(...args);
          timeout = null;
        },
        limit - (now - lastCall)
      );
    }
  } as T;
}


src\shared\utils\timeStamp.ts
export function getTimeStamp(date: string): number {
  return date ? Date.now() - new Date(date).getTime() : 0;
}


src\shared\utils\handlers\handleMatchPair.ts
import type { Tile } from '@/components/GameCanvas/GameCanvas.types';
import { useGameStore } from '@/stores/useGameStore';

interface HandleMatchPairOptions {
  playMatch: () => Promise<void>;
  checkIfGameOver: () => boolean;
  playWin: () => Promise<void>;
  onGameOver: () => void;
  onMatch?: (a: Tile, b: Tile) => void;
  setGameOver: (value: boolean) => void;
  unlock: () => void;
}

export async function handleMatchPair(a: Tile, b: Tile, opts: HandleMatchPairOptions) {
  a.matched = true;
  b.matched = true;
  a.haloAngle = 0;
  b.haloAngle = 0;

  if (opts.onMatch) opts.onMatch(a, b);

  await opts.playMatch();

  useGameStore().incrementMatch(a, b);

  if (opts.checkIfGameOver()) {
    await opts.playWin();
    opts.setGameOver(true);
    opts.onGameOver();
  }

  opts.unlock();
}


src\shared\utils\handlers\handleMismatchPair.ts
import type { Tile } from '@/components/GameCanvas/GameCanvas.types';
import { useGameStore } from '@/stores/useGameStore';

interface HandleMismatchPairOptions {
  playFail: () => Promise<void>;
  drawBoard: () => void;
  onMismatch?: (a: Tile, b: Tile) => void;
  unlock: () => void;
}

export async function handleMismatchPair(a: Tile, b: Tile, opts: HandleMismatchPairOptions) {
  await opts.playFail();

  if (opts.onMismatch) opts.onMismatch(a, b);

  await new Promise((resolve) => setTimeout(resolve, 1000));

  a.flipped = false;
  b.flipped = false;

  opts.drawBoard();

  opts.unlock();
  useGameStore().incrementMismatch(a, b);
}


src\stores\useGameHistoryStore.ts
import type { GameHistoryEntry } from '@/components/GameCanvas/GameCanvas.types';
import { defineStore } from 'pinia';
import { computed, ref } from 'vue';

const STORAGE_KEY = 'memory-game-history';

export const useGameHistoryStore = defineStore('gameHistory', () => {
  const history = ref<GameHistoryEntry[]>([]);

  function loadFromStorage() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      history.value = raw ? JSON.parse(raw) : [];
    } catch {
      history.value = [];
    }
  }

  function addEntry(entry: GameHistoryEntry) {
    history.value.unshift(entry);
    history.value = history.value.slice(0, 10);
    saveToStorage();
  }

  function clearHistory() {
    history.value = [];
    saveToStorage();
  }

  function saveToStorage() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(history.value));
  }

  const stats = computed(() => {
    const games = history.value.length;
    const avgTime = games ? Math.round(history.value.reduce((a, e) => a + e.time, 0) / games) : 0;
    const avgMoves = games ? Math.round(history.value.reduce((a, e) => a + e.moves, 0) / games) : 0;
    return { games, avgTime, avgMoves };
  });

  return {
    history,
    addEntry,
    clearHistory,
    loadFromStorage,
    stats,
  };
});


src\stores\useGameStore.ts
import type { GameState, MatchRecord, Tile } from '@/components/GameCanvas/GameCanvas.types';
import { generateShuffledTiles } from '@/shared/utils/generateTiles';
import { isDifficultyType } from '@/shared/utils/isDifficultyType';
import { getTimeStamp } from '@/shared/utils/timeStamp';
import { defineStore } from 'pinia';
import { computed, ref } from 'vue';

export const useGameStore = defineStore('game', () => {
  const dateStart = ref<string | null>(null);
  const seed = ref('');
  const difficulty = ref(1);
  const tiles = ref<Tile[]>([]);
  const moves = ref(0);
  const elapsed = ref(0);
  const matchCount = ref(0);
  const mismatchCount = ref(0);
  const matchedPairs = ref<MatchRecord[]>([]);
  const gameStarted = ref(false);
  const gameOver = ref(false);
  const sidebarVisible = ref(true);
  const devPanelVisible = ref(false);

  function startGame(payload: { seed: string; difficulty: number }) {
    const newSeed = payload.seed?.trim() || Date.now().toString();
    const newDifficulty = isDifficultyType(payload.difficulty) ? payload.difficulty : 1;

    seed.value = newSeed;
    difficulty.value = newDifficulty;

    const generatedTiles = generateShuffledTiles(newSeed, newDifficulty);
    tiles.value = generatedTiles;
    moves.value = 0;
    elapsed.value = 0;
    gameOver.value = false;
    gameStarted.value = true;
    matchedPairs.value = [];
    matchCount.value = 0;
    mismatchCount.value = 0;
    dateStart.value = new Date().toISOString();
  }

  function restartGame() {
    const generatedTiles = generateShuffledTiles(seed.value, difficulty.value);
    tiles.value = generatedTiles;
    moves.value = 0;
    elapsed.value = 0;
    gameOver.value = false;
    matchedPairs.value = [];
    matchCount.value = 0;
    mismatchCount.value = 0;
  }

  function restoreGame(state: GameState) {
    dateStart.value = state.dateStart ?? null;
    seed.value = state.seed;
    difficulty.value = state.difficulty;
    tiles.value = state.tiles;
    elapsed.value = state.elapsedSeconds;
    moves.value = state.moves;
    gameStarted.value = true;
    gameOver.value = false;
    matchedPairs.value = state?.matchedPairs ?? [];
    matchCount.value = state?.matchCount ?? 0;
    mismatchCount.value = state?.mismatchCount ?? 0;
  }

  function incrementMatch(a: Tile, b: Tile) {
    const { haloAngle: haloAngleA, ...restA } = a ?? {};
    const { haloAngle: haloAngleB, ...restB } = b ?? {};
    matchCount.value++;
    const timestamp = getTimeStamp(dateStart.value as string);
    matchedPairs.value.push({ a: restA, b: restB, result: 'match', timestamp });
  }

  function incrementMismatch(a: Tile, b: Tile) {
    const { haloAngle: haloAngleA, ...restA } = a ?? {};
    const { haloAngle: haloAngleB, ...restB } = b ?? {};
    mismatchCount.value++;
    const timestamp = getTimeStamp(dateStart.value as string);
    matchedPairs.value.push({ a: restA, b: restB, result: 'mismatch', timestamp });
  }

  function resetStats() {
    matchCount.value = 0;
    mismatchCount.value = 0;
    matchedPairs.value = [];
  }

  function incrementMoves() {
    moves.value++;
  }

  function incrementTime() {
    elapsed.value++;
  }

  function setGameOver(val: boolean) {
    gameOver.value = val;
  }

  function setGameStarted(val: boolean) {
    gameStarted.value = val;
  }

  function toggleDevPanel() {
    devPanelVisible.value = !devPanelVisible.value;
  }

  function toggleSidebar(val?: boolean) {
    if (typeof val === 'boolean') sidebarVisible.value = val;
    else sidebarVisible.value = !sidebarVisible.value;
  }

  const gameState = computed(() => ({
    dateStart: dateStart.value,
    tiles: tiles.value,
    elapsedSeconds: elapsed.value,
    moves: moves.value,
    seed: seed.value,
    difficulty: difficulty.value,
    matchCount: matchCount.value ?? 0,
    mismatchCount: mismatchCount.value ?? 0,
    matchedPairs: matchedPairs.value ?? [],
  }));

  return {
    dateStart,
    seed,
    difficulty,
    tiles,
    moves,
    elapsed,
    gameStarted,
    gameOver,
    startGame,
    restartGame,
    restoreGame,
    incrementMoves,
    incrementTime,
    matchCount,
    mismatchCount,
    matchedPairs,
    incrementMatch,
    incrementMismatch,
    resetStats,
    setGameOver,
    setGameStarted,
    gameState,
    devPanelVisible,
    toggleDevPanel,
    sidebarVisible,
    toggleSidebar,
  };
});


src\stores\useSoundStore.ts
import { Howler } from 'howler';
import { defineStore } from 'pinia';
import { ref, watch } from 'vue';

export const useSoundStore = defineStore('sound', () => {
  const isMuted = ref(false);
  const volume = ref(1);

  watch(
    [isMuted, volume],
    ([muted, vol]) => {
      Howler.volume(muted ? 0 : vol);
    },
    { immediate: true }
  );

  function toggleMute() {
    isMuted.value = !isMuted.value;
  }

  function setVolume(v: number): void {
    volume.value = Math.max(0, Math.min(1, v));
  }

  return {
    isMuted,
    volume,
    toggleMute,
    setVolume,
  };
});


